<?xml version="1.0" encoding="UTF-8"?>
<ci.CodeInspectorResult>
	<summary>
		<prjName></prjName>
		<toolName>CodeScroll Code Inspector</toolName>
		<toolVersion>3.7.6.201805181041</toolVersion>
		<numberOfCodeViolation>219</numberOfCodeViolation>
	</summary>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<crc32>8fca5527</crc32>
	</source>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<crc32>d46300a5</crc32>
	</source>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<crc32>4b9511cd</crc32>
	</source>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<crc32>9743c5d2</crc32>
	</source>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<crc32>ca4f4382</crc32>
	</source>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_01_01</rule>
		<ruleTitle><![CDATA[프로그램은 C 표준과 사용하는 컴파일러의 번역 제한을 준수해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
프로그램은 C90 또는 C99 표준에서 명시된 특성과 라이브러리만 사용해야 한다. 표준에서는 컴파일러마다 확장 요소를 제공할 수 있도록 허용하기 때문에, 이 규칙에서는 이러한 확장 요소들을 사용하는 것 역시 허용된다. 임베디드 컴파일러 대부분은 하드웨어 의존적인 코드를 더 효율적으로 작성하기 위해 확장 요소들을 제공한다. 이런 확장 요소들은 C 표준에서 명시하고 있지 않은 추가적인 특성들을 위한 경우가 많으므로 대부분 이 규칙에서 허용된다.<br/><br/>
C 표준에서는 문장 블록 중첩 수, #include 중첩 수 등 번역 제한(translation limits)을 명시하고 있다. 컴파일러에 따라 제한 수치는 더 클 수도 있다. 모든 프로그램은 컴파일러에서 제공하는 번역 제한 수치에 맞춰서 작성되어야 한다.<br/>
C99 표준에서 명시하는 번역 제한은 다음과 같다.<br/>
- 문장 블록 중첩 수: 127<br/>
- #if...#else 중첩 수: 63<br/>
- 하나의 선언에서 포인터, 배열, 함수 선언 조합 수: 12<br/>
- 하나의 선언에서 괄호 선언 중첩 수: 63<br/>
- 하나의 수식에서 괄호 수식 중첩 수: 63<br/>
- 내부 식별자 혹은 매크로 이름의 중요 캐릭터(significant character) 수: 63<br/>
- 외부 식별자의 중요 캐릭터(significant character) 수: 31<br/>
- 하나의 번역 단위에서 외부 식별자 수: 4095<br/>
- 하나의 문장 블록에서 선언되는 식별자 수: 511<br/>
- 하나의 번역 단위에서 정의되는 매크로 식별자 수: 4095<br/>
- 하나의 함수 정의에서 파라미터 수: 127<br/>
- 하나의 함수 호출에서 인자 수: 127<br/>
- 하나의 매크로 정의에서 파라미터 수: 127<br/>
- 하나의 매크로 호출에서 인자 수: 127<br/>
- 하나의 논리적 소스 라인에 캐릭터 수: 4095<br/>
- 하나의 문자열 상수에 캐릭터 수: 4095<br/>
- 객체 바이트 크기(호스트 환경에서만 유효): 65,535<br/>
- #include 중첩 수: 15<br/>
- 하나의 switch에서 case 수: 1023<br/>
- 하나의 struct, union에서 멤버 필드 수: 1023<br/>
- 하나의 enum에서 enumerator 수: 1023<br/>
- 하나의 구조체 선언에서 struct, unit 정의 중첩 수: 63<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 2.1, Rule 1.2<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_01_02</rule>
		<ruleTitle><![CDATA[언어 확장을 사용하면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
컴파일러의 확장 요소들에 의존적인 코드는 이식성이 낮다. 표준에서는 확장 요소들에 대한 설명 문서를 요구하지만, 이런 문서들이 모든 환경에서 모든 동작들을 다 설명하지 못한다는 위험 요소도 존재한다.<br/><br/>
임베디드 시스템에서 컴파일러에서 제공하는 언어 확장 요소를 사용하는 것은 필요한 일이다. 단, 표준에서 정의한 동작을 변경시키는 확장 요소는 사용하지 말아야 한다. 예를 들어, 표준에서는 &&, ||의 우변은 좌변의 결과에 따라 계산되지 않을 수도 있다. 만일 어떤 컴파일러에서 좌변의 결과와 무관하게 우변이 항상 계산된다면, 이런 확장 요소는 이 규칙에 위배된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 1.1<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_01_03</rule>
		<ruleTitle><![CDATA[정의되지 않거나 명시되지 않은 행동이 발생하면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
프로그램이 예상한 방식으로 동작하지 않으면 정의되지 않은 행동(Undefined behaviour)이거나 명시되지 않은 행동(Unspecified behaviour)이다. 단순히 이식성의 문제일 수도 있으나, 더 심각한 문제가 발생할 수도 있다. 예를 들면, 정의되지 않은 행동은 계산 결과를 다르게 할 수 있다. 소프트웨어의 동작이 이 계산에 달려있다면 시스템의 안전도 보장할 수 없다. 문제는 이런 정의되지 않은 행동이 아주 드문 상황에만 나타나기 때문에 찾기가 매우 어렵다는 것이다.<br/><br/>
MISRA C:2012의 많은 규칙들이 이 문제를 피하기 위해 설계되었다. 예를 들어 Rule 11.4, Rule 11.8, Rule 19.2는 C90의 [Undefined 39], C99의 [Undefined 61]을 피하기 위해 정의되었다. 그 외 항목들에 대해서는 특정 규칙으로 정의하지 않았는데 그 이유는 거의 일어날 가능성이 없거나, 아니면 현실적인 가이드라인을 정의할 수 없기 때문이다. 그러나 구체적인 가이드라인을 제공하지 못하더라도 이 항목들을 매우 중요하게 취급되도록 하기 위해 별도의 규칙으로 정의한다.<br/><br/>
기존 MISRA C:2004의 Rule 1.2, Rule 18.1, Rule 19.8, Rule 19.14, Rule 20.6이 이 규칙으로 병합되었다(MISRA C:2012 Addendum 1 — Rule Mappings 참조).<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.1<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_19_01</rule>
		<ruleTitle><![CDATA[오버랩되는 객체에 할당 또는 복사 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
두 객체가 메모리 영역 내에서 overlap 되어 생성되고 한 객체가 다른 객체에 복사되거나 할당되는 경우, 이것은 정의되지 않은 행동이다.<br/><br/>
다음의 경우는 예외이다.<br/><br/>
 1. 정확히 overlap 되었고, 호환되는 타입의 두 객체의 할당(타입한정자 무시)<br/>
 2. 표준 라이브러리 함수 memmove를 사용하여 부분적 또는 완전하게 overlap된 객체 간의 복사<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 19.2<br/>]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_19_02</rule>
		<ruleTitle><![CDATA[union 키워드 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
잘 정의된 유니온 멤버에는 값을 할당할 수 있고, 그 후 같은 멤버 값을 사용할 수 있다.
<br/><br/>
하지만 유니온 멤버에 값을 할당한 후 다른 유니온 멤버를 읽는다면,  그 행동은 다음과 같이 멤버의 상대적인 크기에 의존한다:<br/><br/>
 - 만약 할당된 멤버보다 읽으려는 멤버 크기가 더 큰 경우 그 값은 보장할 수 없다.<br/>
 - 그렇지 않으면, 값은 implementation-defined 이다.
 <br/><br/>
표준에서는 unsigned char 타입의 배열 타입인 멤버로 다른 유니온 멤버의 byte로의 접근을 허용한다.
하지만, 불특정한 byte로의 접근이 가능하기 때문에, union을 사용해서는 안된다.
<br/><br/>
먄약 이 규칙을 따르지 않는다면, 다음의 행동을 결정해야 한다:<br/><br/>
 - Padding - union의 끝에 얼마나 많은 패딩이 추가되는지<br/>
 - Alignment - union 내 구조체 멤버들이 어떻게 정렬되는지<br/>
 - Endianness - word의 최상위 바이트가 메모리 주소의 가장 낮거나 가장 높은곳에 위치하는지<br/>
 - Bit-order - bit가 byte 내에서 어떻게 정렬되는지, 그리고 어떻게 bit가 bit field로 할당되는지<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 19.1<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_01</rule>
		<ruleTitle><![CDATA[함수 포인터와 다른 타입 간의 형 변환 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

함수를 가리키는 포인터로/부터의 다음으로의 형변환:</br></br>

- 객체를 가리키는 포인터</br>
- 불완전 타입(incomplete) 객체를 가리키는 포인터</br>
- void*</br></br>
에 대한 동작은 정의되지 않았다.</br></br>

만약 어떤 함수가 호출된 함수와 호환되지 않는 타입을 갖는 포인터의 값으로 호출된 경우 이 결과는 표준에 의해 정의되지 않았다. 단, 함수를 가리키는 포인터를 다른 타입의 함수를 가리키는 포인터로 변환하는 것은 표준에 의해 허용된다. 정수형 값을 함수를 가리키는 포인터로 변환하는 동작도 표준에 의해 허용된다. 그러나 호환가능하지 않은 포인터 타입을 사용하는 함수를 호출하는 결과에 대한 동작이 정의되지 않았고, <b>이를 피하기 위해 이 규칙에서는 위에서 말한 두가지 모두를 금지한다.</b>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_03</rule>
		<ruleTitle><![CDATA[한 객체 포인터로와 다른 객체 포인터 간의 변환 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<b>이 규칙은 포인터의 한정자(const, volatile 등)가 명시되지 않은 타입을 가리키는 경우에 적용된다.</b></br></br>

객체를 가리키는 포인터를 다른 객체를 가리키는 포인터로 변환하는 것은 메모리 정렬(align)을 제대로 맞출 수 없고, 따라서 이러한 객체의 사용은 정의되지 않은 동작이 발생시킬 수 있다.</br></br>

변환이 메모리 정렬이 제대로 맞게끔 수행된다 하더라도 해당 포인터를 통해 객체에 접근하는 경우 객체가 서로 호환되지 않는 경우 정의되지 않은 동작이 발생할 수 있다. 예를 들어 만약 int 타입의 어떤 객체가 short 타입의 포인터를 통해 접근되는 경우에 int와 short가 동일한 데이터 표현법과 alignment를 가진다 하더라도 이에 대한 동작은 정의되지 않았다. C90 표준의 6.3과 C99 표준의 6.5의 7번째 단락에 자세히 설명되어 있다.
</br></br>

<b>예외사항</b></br>
- <b>char, signed char, unsigned char</b>를 가리키는 포인터 간의 변환은 허용된다. 이 타입들이 독립된 byte단위로 접근할수 있게끔 표준이 보장하기 때문이다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.4, Rule 11.5, Rule 11.8<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_02</rule>
		<ruleTitle><![CDATA[불완전 포인터(incomplete)타입과 다른 타입 간의 형 변환 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

불완전 타입과의 변환은 메모리 정렬(align)을 제대로 맞추지 못할 수 있고 예기치 못한 동작을 발생시킬 수 있다.</br>
특히, 불완전 타입과 부동소수 타입간의 변환에 대한 동작은 정의되지 않았다.</br></br>

불완전 타입을 가리키는 포인터는 때때로 어떤 객체의 표현방법을 숨기기 위해 사용된다. 따라서 불완전 타입을 가리키는 포인터로부터 객체를 가리키는 포인터로 변환하는 것은 이 캡슐화를 깨뜨릴 수 있다.
</br></br>
<b>예외사항</b></br></br>
&nbsp;&nbsp;&nbsp;&nbsp;1. null 포인터 상수는 불완전 타입을 가리키는 포인터로 변환될 수 있다.</br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 불완전 타입을 가리키는 포인터는 void로 변환될 수 있다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.5<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[매크로 NULL은 정수 null 포인터 상수만으로 사용해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

0 대신 NULL을 씀으로써 null 포인터 상수가 사용되었음을 더 명확히 하여라.<br/><br/>
만약 아래와 같은 경우에서 0의 값을 갖는 정수 상수식이 나왔다면 그것은 매크로 NULL을 통해 사용된 것이어야 한다:</br>

- 해당 값이 포인터에 할당되는 경우</br>
- 연산자 ==나 !=의 다른 피연산자가 포인터인 경우</br>
- ?:연산자의 세 번째 피연산자가 포인터인 경우 두 번째 피연산자에 쓰일 때</br>
- ?:연산자의 두 번째 피연산자가 포인터인 경우 세 번째 피연산자에 쓰일 때
</br></br>
공백과 괄호들 무시하고 난 후 이러한 정수 상수식들은 확장된 매크로 NULL을 표현할 수 있어야 한다.</br>
(void*) 0의 꼴로 만들어진 null 포인터 상수는 매크로 NULL이 확장되었든 그렇지 않든 허용한다.</br>

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.4<br>
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_08</rule>
		<ruleTitle><![CDATA[형 변환 시 포인터의 const 또는 volatile 제거금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

변환을 통해 명시된 타입의 한정자를 제거하려는 시도는 타입 한정자의 원칙을 위반하는 것이다.</br>
여기에서 말하는 한정자는 포인터 자체에 적용된 한정자를 말하는 것이 아니라는 점에 주의하라.</br></br>

명시된 타입의 한정자를 제거한다면 다음과 같은 문제가 발생할 수 있다:</br></br>
- const 한정자를 제거하게 된다면 객체의 읽기전용 상태를 우회할 수 있게 되고 따라서 객체가 수정될 수 있게 된다.</br>
- const 한정자를 제거하는 것은 객체에 접근할 때 exception을 발생시킬 수 있다.</br>
- volatile 한정자를 제거하는 것은 컴파일러에 의해 최적화된 객체에 접근하게끔 할 수 있다.</br></br>

<b>참조</b> C99의 restrict 타입 한정자를 제거하는 것은 가능하다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.3<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_05</rule>
		<ruleTitle><![CDATA[void 포인터에서 객체 포인터로 변환 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

void를 가리키는 포인터를 객체를 가리키는 포인터로 변환하는 것은 해당 포인터의 메모리 정렬(align)을 깨뜨릴 수 있고 따라서 정의되지 않은 동작을 발생시킬 수 있다. 가능하다면 이를 피해야 하지만 메모리 할당 함수와 같이 꼭 필요한 경우가 있다. 만약 객체를 가리키는 포인터를 void를 가리키는 포인터로 변환했다면 [MISRA_C_2012_11_03] 에서 다룬 정의되지 않은 동작이 발생하지 않도록 주의를 기울여야 한다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.2, Rule 11.3<br>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_04</rule>
		<ruleTitle><![CDATA[객체 포인터와 정수형 타입 간의 변환 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

void를 가리키는 포인터를, 객체를 가리키는 포인터로 변환하는 것은 해당 포인터의 메모리 정렬(align)을 깨뜨릴 수 있고 따라서 정의되지 않은 동작을 발생시킬 수 있다. 가능하다면 이를 피해야 하지만 메모리 할당 함수와 같이 꼭 필요한 경우가 있다. 만약 객체를 가리키는 포인터를 void를 가리키는 포인터로 변환했다면 [MISRA_C_2012_11_03]에서 다룬 정의되지 않은 동작이 발생하지 않도록 주의를 기울여야 한다.</br></br>

<b>예외사항</b></br></br>
- 가리키는 타입이 void로 선언된 null 포인터 상수는 객체를 가리키는 포인터로 변환될 수 있다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.3, Rule 11.7, Rule 11.9<br>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_07</rule>
		<ruleTitle><![CDATA[객체 포인터와 정수가 아닌 산술 타입 간의 변환금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

이 규칙을 위한 정수가 아닌 산술형 타입은 다음과 같다.</br></br>
- Essential 타입이 Boolean인 타입</br>
- Essential 타입이 character인 타입</br>
- Essential 타입이 enum인 타입</br>
- Essential 타입이 floating인 타입</br></br>

Essential 타입이 Boolean, character, enum인 타입을 객체를 가리키는 포인터로 변환하는 것은 해당 포인터의 메모리 정렬(align)을 깨뜨릴 수 있고 따라서 정의되지 않은 동작을 발생시킬 수 있다.</br>
객체를 가리키는 포인터를 Essential 타입이 Boolean, character, enum인 객체로 변환하는 것은 선택된 정수 타입으로 표현 불가능한 값을 만들 수 있고 이에 따라 정의되지 않은 동작을 발생시킬 수 있다. 또한, 객체를 가리키는 포인터와 essential 타입이 floating인 타입간의 변환은 정의되지 않았다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.4<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_06</rule>
		<ruleTitle><![CDATA[void 포인터와 산술 타입 간의 변환 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

정수형 타입을 void를 가리키는 포인터로 변환하는 것은 해당 포인터의 메모리 정렬(align)을 깨뜨릴 수 있고 따라서 정의되지 않은 동작을 발생시킬 수 있다.</br>
void를 가리키는 포인터를 정수형 타입으로 변환하는 것은 선택된 정수 타입으로 표현 불가능한 값을 만들 수 있고 이에 따라 정의되지 않은 동작을 발생시킬 수 있다.</br>

정수가 아닌 산술형 타입과 void를 가리키는 타입간의 변환은 정의되지 않았다.</br></br>

<b>예외사항</b></br></br>
- 정수형 타입의 null 포인터 상수는 객체를 가리키는 포인터로 변환될 수 있다.
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_09</rule>
		<ruleTitle><![CDATA[내부 연결을 갖는 변수나 함수 식별자는 유일해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
식별자 이름은 모든 name space와 translation unit에서 유일해야 한다. 연결(linkage) 정보가 없는 지역 변수 식별자들도 유일해야 한다. 이런 식으로 식별자 이름의 유일성을 강조하면 개발자의 혼란을 막을 수 있다.<br/>
단, 내부 연결을 갖는 inline 함수를 하나의 헤더 파일에서 정의해서 여러 translation unit에서 include해서 사용하는 것은 허용된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 8.10<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_03</rule>
		<ruleTitle><![CDATA[안쪽 scope의 식별자를 바깥 scope의 식별자가 가리면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
안쪽 scope의 식별자는 어떤 바깥 scope의 식별자와도 구별할 수 있어야 한다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. 대부분의 컴파일러들은 외부 식별자를 최소 31자이상, 대소문자 구분하여 비교했을 때 구별되어야 한다고 정의한다.<br/>
안쪽 scope에 선언된 식별자가 바깥 scope에 선언된 식별자와 구별되지 않으면, 가장 안쪽의 식별자 선언은 가려지게(hide) 된다. 이는 개발자에게 혼란을 준다.<br/>
참고록 서로 다른 name space 에 있는 식별자 끼리는 서로 가리지 않는다.<br/>
안쪽(inner)와 바깥(outer) scope는 다음과 같이 설명할 수 있다.<br/>
- file scope 는 가장 바깥이다.<br/>
- 블록 scope가 더 안쪽이다.<br/>
- 연속, 중첩된 블록들은 더 안쪽이다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.2, Rule 5.8<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_04</rule>
		<ruleTitle><![CDATA[매크로의 식별자는 구별되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
전처리 전에 존재하는 매크로 이름들과 전처리 후 남아 있는 식별자들은 구별되어야 한다. scope나 name space에 무관하게 모든 매크로 이름들과 식별자들에 적용된다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. C90에서는 처음 31자, C99에서는 처음 63자를 중요(significant)하다고 정의하지만, 실제로 많은 컴파일러들이 더 긴 중요 문자로 구별한다.<br/>
매크로 이름과 식별자를 구별하는 것은 개발자의 혼란을 막을 수 있다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.1, Rule 5.2, Rule 5.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_01</rule>
		<ruleTitle><![CDATA[외부 식별자는 구별되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
이 규칙은 컴파일러 자체 번역 제한(translation limits) 내에서 외부 식별자가 구별되어야 함을 말한다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. 대부분의 컴파일러들은 외부 식별자를 최소 31자 이상, 대소문자 구분하여 비교했을 때 구별되어야 한다고 정의한다.<br/>
만약 두 식별자가 중요 문자 안에서 차이가 없으면, 정의하지 않은 행동을 일으킬 수 있다.<br/>
이식성이 중요하다면, 현재 사용 중인 컴파일러보다 표준에서 정의한 최소한의 제한을 따르는 것이 안전하다.<br/>
너무 긴 식별자는 가독성을 저하시킨다. 자동으로 생성한 코드는 긴 식별자를 가지기 쉬운데, 가능하면 식별자 길이를 표준에서 정의하는 제한하는 것이 좋다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 1.1, Rule 5.2, Rule 5.5<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_02</rule>
		<ruleTitle><![CDATA[같은 scope 혹은 name space에 선언된 식별자는 구별되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
이 규칙은 외부 식별자끼리 비교하는 것은 Rule 5.1에서 검사하므로 제외한다.<br/>
그리고 둘 중 하나가 매크로 식별자인 경우에도 Rule 5.4와 Rule 5.5에서 검사하므로 제외한다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. 대부분의 컴파일러들은 외부 식별자를 최소 31자이상, 대소문자 구분하여 비교했을 때 구별되어야 한다고 정의한다.<br/>
만약 두 식별자가 중요 문자 안에서 차이가 없으면, 정의하지 않은 행동을 일으킬 수 있다.<br/>
이식성이 중요하다면, 현재 사용 중인 컴파일러보다 표준에서 정의한 최소한의 제한을 따르는 것이 안전하다.<br/>
너무 긴 식별자는 가독성을 저하시킨다. 자동으로 생성한 코드는 긴 식별자를 가지기 쉬운데, 가능하면 식별자 길이를 표준에서 정의하는 제한하는 것이 좋다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 1.1, Rule 5.1, Rule 5.3, Rule 5.4, Rule 5.5<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_07</rule>
		<ruleTitle><![CDATA[tag(struct, union, enum) 이름은 유일한 식별자여야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
tag는 모든 name space와 translation unit에서 유일해야 하며, 모든 같은 이름의 tag 선언은 동일한 타입이어야 한다. 헤더 파일에 tag 를 선언하고 그 헤더 파일을 여러 파일에서 포함하여 사용할 때만 tag 를 중복선언하는 것을 허용한다.<br/>
tag 이름을 재사용하면 개발자에게 혼란을 줄 수 있다.<br/>
또한 tag 이름을 재사용하는 것은 정의하지 않은 행동이기도 하다. 이 제약은 C90에서는 식별되지 않았으나 C99에는 포함되어 있다(Section 6.7.2.3).<br/>
단, typedef struct list { ... } list; 처럼 struct, union, enum을 선언할 때 동일한 이름으로 typedef하는 것은 허용된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.6<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_08</rule>
		<ruleTitle><![CDATA[외부 연결을 갖는 변수나 함수 식별자는 유일해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
외부 연결을 갖는 식별자는 어떤 name space나 translation unit에서도 다른 목적으로 사용되면 안 된다. 이런 식으로 식별자 이름의 유일성을 강조하면 개발자의 혼란을 막을 수 있다.<br/>
연결(linkage) 정보가 없는 지역 변수 식별자는 이런 혼란의 위험 요소가 적으므로 유일하지 않아도 된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.3<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_05</rule>
		<ruleTitle><![CDATA[식별자는 매크로 이름과 구별되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
매크로가 정의될 때 그 이름이 다른 정의된 매크로 이름들과 자기 자신의 파라미터 이름들과 구별되어야 한다. 또한 하나의 함수형 매크로에서 파라미터 이름들 끼리도 구별되어야 한다. 서로 다른 매크로들 간에 파라미터 이름은 구별되지 않아도 된다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. C90에서는 처음 31자, C99에서는 처음 63자를 중요(significant)하다고 정의하지만, 실제로 많은 컴파일러들이 더 긴 중요 문자로 구별한다.<br/>
만약 두 매크로 식별자가 중요 문자 안에서 차이가 없으면, 정의하지 않은 행동을 일으킬 수 있다. 매크로 파라미터는 그 매크로가 확장될 때만 유효하므로 다른 매크로의 파라미터들과 혼동될 가능성은 없다.<br/>
이식성이 중요하다면, 현재 사용 중인 컴파일러보다 표준에서 정의한 최소한의 제한을 따르는 것이 안전하다.<br/>
너무 긴 매크로 식별자는 가독성을 저하시킨다. 자동으로 생성한 코드는 긴 식별자를 가지기 쉬운데, 가능하면 식별자 길이를 표준에서 정의하는 제한하는 것이 좋다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.1, Rule 5.2, Rule 5.5<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_06</rule>
		<ruleTitle><![CDATA[typedef 이름은 유일한 식별자여야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
typedef 이름은 모든 name space와 translation unit들에서 유일해야 한다. 헤더 파일에서 한 typedef 이름으로 타입을 정의하고 그 헤더 파일을 여러 파일에서 include 해서 사용할 때만 중복해서 선언하는 것을 허용한다.<br/>
typedef 이름을 다른 typedef 이름이나 함수 이름, 변수 이름, enum 상수 이름으로 사용하면 개발자에게 혼란을 줄 수있다.<br/>
단, typedef struct list { ... } list; 처럼 struct, union, enum을 선언할 때 동일한 이름으로 typedef하는 것은 허용된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.7<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_04</rule>
		<ruleTitle><![CDATA[읽기 전용으로 열린 스트림에 쓰기를 하면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
표준에서는 읽기 전용 스트림에 쓰기를 시도하는 경우, 그에 따른 행동을 명시하지 않고 있으므로, 읽기 전용 스트림에 쓰기를 시도하는 것은 안전하지 않다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_05</rule>
		<ruleTitle><![CDATA[FILE 객체를 가리키는 포인터는 dereference되면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
FILE 객체에 대한 포인터는 직, 간접적(memcpy나 memcmp 호출 시 인자로 사용)으로 dereference되면 안 된다.<br/>
표준(C90 Section 7.9.3(6), C99 Section 7.19.3(6))에서는 FILE 객체의 주소는 스트림을 제어하는데 매우 중요하며, 객체의 사본으로는 동일한 동작을 보장할 수 없다고 말한다. 따라서 이런 사본이 생성되지 않도록 막기 위해 이 규칙이 필요하다.<br/>
FILE 객체에 대한 직접적인 조작은 금지된다. 이렇게 조작된 객체를 스트림 지정자로 사용 시 호환되지 않을 가능성이 있기 때문이다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[기타]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_06</rule>
		<ruleTitle><![CDATA[FILE 객체를 가리키는 포인터를 해당 스트림이 닫힌 후에 사용하면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
표준에서는 FILE 객체의 해당 스트림이 닫힌 후에는 FILE 포인터의 값은 불확실하다고 기술되어 있다. 따라서 이 포인터의 값을 사용하는 것은 안전하지 않다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.13, Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_01</rule>
		<ruleTitle><![CDATA[표준 라이브러리를 통해 동적으로 얻은 리소스는 명시적으로 해제되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
자원을 할당하는 표준 라이브러리 함수는 malloc, calloc, realloc 그리고 fopen이다.<br/>
자원이 명시적으로 해제되지 않는다면 이로 인해 자원의 고갈이 발생하는 것이 가능하다. 가능한 빨리 자원을 해제하는 것은 자원 고갈의 가능성을 줄여준다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.12, Dir 4.13, Rule 21.3, Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_02</rule>
		<ruleTitle><![CDATA[메모리는 시스템 라이브러리 함수를 통해 할당되었을 때만 해제되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
메모리를 할당하는 표준 라이브러리 함수는 malloc, calloc, realloc이다.<br/>
할당되지 않은 메모리를 해제하거나 같은 곳에 할당된 메모리를 한번 이상 해제하는 것은 정의되지 않은 행동을 유발한다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.12, Dir 4.13, Rule 21.3<br/>]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_03</rule>
		<ruleTitle><![CDATA[서로 다른 스트림에서 같은 파일을 동시에 읽기, 쓰기로 열면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
서로 다른 스트림에서 같은 파일을 동시에 읽기, 쓰기로 열면 안 된다. 표준에서는 이런 경우에 대한 동작을 명시하지 않고 있으므로, 의도한 동작을 보장할 수 없다.<br/>
단, 같은 파일을 읽기 전용으로 서로 다른 스트림에서 여러 번 여는 것은 가능하다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_07_03</rule>
		<ruleTitle><![CDATA[소문자 접미사 "l" 은 사용하면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
접미사 대문자 "L"을 써야 "1(숫자 1)" 이나 "ㅣ(문자 "el")"과 구분하기 쉽다.<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_07_04</rule>
		<ruleTitle><![CDATA[문자열을 const char * 타입이 아닌 객체에 할당하면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
문자열 상수를 변경하는 것은 정의되지 않은 동작을 일으킬 수 있다. 예를 들어 어떤 컴파일러는 문자열 상수를 read-only 메모리에 저장하는데, 이런 경우 런타임에 예외나 crash가 발생할 수 있다.<br/>
따라서 const char *로 선언한 변수에 할당해서, 값을 변경하지 못하도록 하는 것이 안전하다. 또한 & 연산의 결과는 const char(*)[] 타입 변수에 할당해야 안전하다.<br/>
wide 문자열도 마찬가지이다. wide 문자열을 const wchar_t * 타입이 아닌 변수에 할당하면 안 된다.<br/>
C99 표준에 문자열 저장 위치에 대해 명시되어 있지 않으므로 문자열을 성공적으로 바꾼 것 같아도 다른 문자열이 의도하지 않게 수정될 수도 있다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 11.4, Rule 11.8<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_02</rule>
		<ruleTitle><![CDATA[배열, 구조체, 유니온 타입의 초기화는 큰괄호('{ }') 로 둘러쌓여야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<b>이 규칙은 객체와 하위객체에 모두 적용된다.</b> { 0 } 형태의 초기화는 대상의 모든 객체를 0으로 설정하는데 사용되며, 이 경우 하위 객체를 초기화 하기 위해 큰괄호를 사용하지 않아도 된다.<br/><br/>
<b>참고</b> 이 규칙은 객체나 하위 객체의 명시적 초기화를 요구하지 않으며, 초기화가 아예 없는 코드에는 적용되지 않는다.<br/><br/>

하위 객체의 초기화를 위해 큰괄호를 사용하는 것은 코드의 명확성을 향상시키고 개발자가 다차원 배열이나 구조체의 배열과 같은 복잡한 자료구조에서의 초기화를 고려하도록 해준다.</br></br>

<b>예외사항</b></br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 문자열 상수을 사용하여 배열을 초기화 하는 경우</br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 호환되는 구조체나 유니온 표현식을 이용해서 구조체나 유니온을 초기화하는 경우</br>
&nbsp;&nbsp;&nbsp;&nbsp;3. <b>지정 초기화(designated initializer)</b> 를 이용하여 객체의 일부를 초기화하는 경우</br>
<br/>
<br/>
<b>예제</b><br/>
<textarea id="ex1">
int16_t y[3][2] = { 1,2,0,0,5,6 };       /* 위배 */
int16_t y[3][2] = { {1,2},{0,0},{5,6} }; /* 옳음 */
int16_t y[3][2] = { {1,2,0},{0,5,6} };   /* 옳음 */

struct s1 {
  uint16_t len;
  char buf[8];
} s[3] = {
   { 5u, {'a','b','c','d','e','\0','\0','\0'} },
   { 2u, {0} },                          /* 옳음 */
   { .len = 0u }                         /* 옳음 - 예외 3*/
};
</textarea>

<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_01</rule>
		<ruleTitle><![CDATA[모든 변수는 읽기 전에 할당되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

표준에 따르면, static 변수의 저장 공간은 초기화 해주지 않으면 자동으로 0으로 초기화가 된다. 하지만 일반 변수는 자동으로 초기화 되지 않는다. </br></br>
참조 : 변수에 대한 명시적 초기화가 무시되는 경우가 있을 수 있다. goto문이나 switch문의 사용으로 객체의 선언문을 통과하는 경우에 발생할 것이다.</br></br>

<b>이 규칙의 목적을 위해서, 배열이나 구조체의 멤버 또한 하나의 분리된 객체로 고려해야 한다.</b>
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 15.1, Rule 15.3<br>]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_04</rule>
		<ruleTitle><![CDATA[객체의 요소 두 번 이상 초기화 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

<b>이 규칙은 객체와 하위 객체 모두에 대하여 적용한다.</b></br>

C99표준의 지정 초기화(designated initializers) 규정에서는 집합체(배열 또는 구조체)의 요소에 대한 구조체 필드의 이름을 사용하는 것을 허용하고, 배열의 특정 인덱스를 지정하여 초기화하는 것을 허용한다.</br><br/>

지정 초기화를 사용할 때는 요소의 초기화가 이전의 초기화로 인하여 실수로 덮어씌워질 수 있기 때문에 주의해야한다. C99표준에서는 중복된 초기화문에 대한 부작용을 기술하지 않음으로 컴파일러마다 다른 특성을 가지게 된다(앞선 지정 초기화가 우선일지, 뒤에 나온 지정 초기화가 우선인지 미정의됨). </br>
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_03</rule>
		<ruleTitle><![CDATA[배열은 일부분만 초기화 되면 안됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

배열이나 객체의 일부 요소가 명시적으로 초기화 되면 안된다. 반드시 전체 요소가 명시적으로 초기화 되어야 한다.</br></br>

배열의 모든 요소를 명시적 초기화 하는 것은 모든 요소가 고려되었다는 것을 명확히 할 수 있다.</br></br>

<b>예외사항</b></br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 배열의 모든 하위 요소를 명시적으로 초기화 하기위해 사용된 { 0 } 형태의 초기화문</br>
&nbsp;&nbsp;&nbsp;&nbsp;2. <b>지정 초기화(designated initalizer)</b>로만 배열의 일부가 초기화된 경우</br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 문자열 리터럴을 사용하여 초기화 된 배열</br></br>


<b>예제</b></br>
<textarea id="ex1">
int32_t x[3] = {0, 1};                        /* 위배 */
float32_t z[50] = { [1] = 1.0f, [25] = 2.0f } /* 옳음 - 예외 2 */
float32_t z[50] = { [1] = 1.0f, 2.0f }        /* 위배 - 예외 2 에 맞지 않음 */
</textarea>
<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_05</rule>
		<ruleTitle><![CDATA[지정 초기화(designated initializer)가 사용된 배열은 그 크기가 명시적이어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

배열의 크기가 묵시적이면, 지정 초기화로 명시된 요소중 가장 높은 인덱스로 그 크기가 결정되는데, 지정 초기화문을 사용 할때 항상 가장 높은 인덱스의 초기화문을 필수로 기술하지 않는다. 이 때문에, 이후 이 배열을 사용할때, Buffer Overflow 같은 문제를 발생시킬 수 있다.
배열의 크기와 관련된 명확한 정보 제공을 위해서, 이런 경우 배열의 크기는 명시적으로 선언되어야 한다.

]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_07_02</rule>
		<ruleTitle><![CDATA[unsigned integer 상수에는 접미사 "u"나 "U"를 붙여야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
이 규칙은 전처리 지시자 중 #if, #elif에 사용된 integer 상수와 전처리 후 존재하는 모든 integer 상수에 적용된다.<br/>
다음과 같은 복잡한 원인 때문에 정수형 상수의 타입을 혼동하기 쉽다.<br/>
- 상수의 자릿수(magnitude)<br/>
- 컴파일러에서 정의한 integer 타입 크기<br/>
- 접미사의 존재<br/>
- 진수(10진수, 8진수, 16진수)<br/>
예를 들면, 40000은 32 비트 환경에서는 signed int 이지만 16 비트 환경에서는 signed long 이다. 0x8000은 16비트 환경에서는 unsigned int 이지만 32비트 환경에서는 signed int 이다.<br/>
- 접미사 "U" 가 붙은 상수는 unsigned 타입이다.<br/>
- 2<sup>31</sup> 보다 작고 접미사가 없는 10진수 값은 signed 타입이다.</br>
- 2<sup>15</sup> 보다 크고 접미사가 없는 16진수 값은 signed 혹은 unsigned 타입이다.</br>
- C90에서 2<sup>31</sup> 보다 크거나 같고 접미사가 없는 10진수 값은 signed 혹은 unsigned 타입이다.<br/><br/>

상수의 부호는 명확해야 한다. 만일 unsigned 타입 상수에 접미사 "U"를 붙이면 그 상수는 unsigned 타입이라는 것을 분명하게 알 수 있다.<br/>
이 규칙은 상수가 사용되는 문맥과 무관하다. integer promotion이나 다른 어떤 변환이 발생하더라도 이 규칙을 검사하는 것과는 무관하다.<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_07_01</rule>
		<ruleTitle><![CDATA[8진수 상수는 사용하면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
개발자들이 0으로 시작하는 상수를 기록할 때는 일반적으로 10진수를 의도한 경우가 많다. 그러나 0으로 시작하는 상수는 8진수이므로 개발자의 의도와 다른 값이 사용될 수 있다.<br/>
따라서 0으로 시작하는 8진수 상수를 사용하지 않는 것이 안전하다. escape 시퀀스로 기록하는 것은 10진수와 혼동할 가능성이 낮으므로 허용된다.<br/>
상수 0은 엄밀히 말하면 8진수 상수이다. 그러나 여기서는 위배로 검출하지 않는다.<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_01</rule>
		<ruleTitle><![CDATA[모든 switch 문은 잘 짜여야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

C의  switch 문의 구문은 특별히 엄격하지 않고 복잡한 구조를 허용하는데, 구조화되지 못한 행동이다 . 이 규칙과 다른 규칙들은 switch 문이 단순하고 일관된 구조가 되도록 보장한다.  

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 15.3, Rule 16.2, Rule 16.3, Rule 16.4, Rule 16.5, Rule 16.6<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_02</rule>
		<ruleTitle><![CDATA[switch label 을 포함하는 가장 가까운 문장은  switch 문이어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

표준에서 switch label 인 case 나 default 가 switch 문의 어떤 문장의 몸체에나 포함될 수 있도록 허용하기 때문에, 구조화되지 못한 코드가 될 수 있다. 이를 방지하기 위해 switch label 은 반드시 switch 문의 가장 바깥쪽 몸체에 있어야 한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_03</rule>
		<ruleTitle><![CDATA[모든 switch 절은 break 로 끝나야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

개발자가 실수로 switch 절을 break 로 끝마치지 않으면, 다음 switch 절로 빠져나가거나, 다음 switch 절이 없으면, switch 문의 다음 문장으로 빠져나온다. 다음 switch 절로 빠져나가게 의도했다 하더라도 때로는 오류이다. 제어흐름이 switch 문의 마지막에 있는 break로 끝나지 않는 switch 절에서  나중에 추가되는 switch 절로 빠져나갈 수 있다.
</br></br>
이런 오류를 반드시 발견할 수 있도록, 모든 switch 절의 마지막 문장은 break 이어야 한다.
</br></br>
참조: switch 절은 적어도 하나의 문장은 있어야 정의된다. 따라서 두 연속한 label에 어떤 문장도 없는 경우는 이 규칙에서 허용한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_04</rule>
		<ruleTitle><![CDATA[모든 switch 문에 default label 이 있어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

default label 은 방어적인 프로그래밍을 위해 필요하다. default label 에는 어떤 행동을 하는 문장이 따르거나 문장이 없으면 이유를 밝히는 주석이 있어야 한다. 

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 2.1, Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_05</rule>
		<ruleTitle><![CDATA[default label 은 switch 문장의 맨처음이나 마지막 switch label 이어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

이 규칙은 default label 을 switch 문에 위치시키기 쉽게 한다. switch 문에 default 문장을 사용했는지 쉽게 확인할 수 있고, 제어 흐름을 파악하기 쉽다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 15.7, Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_06</rule>
		<ruleTitle><![CDATA[모든 switch 문에 적어도 둘 이상의 switch 절이 있어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

하나의 경로만 가지는 switch 문은 쓸모가 없고 프로그램 오류일 가능성이 높다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_07</rule>
		<ruleTitle><![CDATA[switch-expression 은 Boolean 타입이면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

표준에 따라 switch 문의 조건식은 정수 타입이어야 한다. Boolean 의 값의 타입은 정수이기 때문에, switch 문을 Boolean 표현식으로 제어하는 것이 가능하다. 이런 경우는 if-else 구조를 사용하는 것이 적절하다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

다른 산술 연산자와 같이 할당 연산자를 사용하는 것은 다음의 이유로 추천하지 않는다:</br></br>
&nbsp; - 코드의 가독성을 해친다.</br>
&nbsp; - 구문의 추가적인 side effect는 [Rule 13.2]에서 커버된 정의되지 않은 행동을 일으킬 수 있다.</br>
</br></br>
<b>할당문이 포함된 표현식이 평가되지 않는다고 하더라도 이 규칙을 적용한다.</b></br></br>

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 13.2</br>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

&&와 || 연산자의 우측 피연산자의 평가 여부는 좌측 피연산자의 값에 의존적이다. 만약 우측 피연산자가 side effect를 포함한다면 이러한 side effect는 프로그래머의 기대와는 다르게  발생하지 않을 수 있다. 
 </br></br>
우측 피연산자의 평가가 프로그램 상에서 그 표현식이 발생하는 곳에서 영구적이지 않은 side effect를 일으킨다면 우측 피연산자가 평가되느냐는 중요하지 않다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_02</rule>
		<ruleTitle><![CDATA[수식의 값과 영구적인 side effect의 평가결과가 평가 순서에 상관없이 같아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

두 인접한 시퀀스 사이나 전체 표현식 내에서 :</br>

&nbsp;	1. 객체는 한번 이상 변형될 수 없다.</br>
&nbsp;	2. 어떠한 객체의 값을 읽는 것이 그 객체로 저장될 값의 계산에 영향을 미치지 않는다면 그 객체는 변형되거나 읽을 수 없다.</br>
&nbsp;	3. 한번 이상 volatile-qualified 타입을 변형할 수 없다.</br>
&nbsp;	4. 한번 이상 volatile-qualified 타입을 읽을 수 없다.</br>

Note : 객체는 표현식에 의해 직접적으로 접근되는 만큼 포인터나 함수 호출에 의해 간접적으로 접근될 수 있다.</br>

Note : 이는 규칙의 제목보다 더욱 엄격하다. 그래서 다음과 같은 표현식</br>

x = x = 0;<br/>

은 값 x가 volatile이 아니라면, 값이 영구적인 side effects가 평가 순서에 독립적이라고 하더라도 허용되지 않는다. <br/>



표현식을 평가할 때 표준에서는 컴파일러들에게 상당한 유연성을 부여한다. 대부분의 연산자는 어떤 순서에서든지 평가된 피연산자를 가지고 있다. 평가되지 않는 피연산자를 가지는 예외 상황은 다음과 같다 :</br></br>

&nbsp; - AND 연산자의 두번째 피연산자는 첫번째 피연산자가 0이 아닌경우에만 평가된다.<br/>
&nbsp; - OR 연산자의 두번째 피연산자는 첫번째 피연산자가 0일 경우에만 평가된다.<br/>
&nbsp; - :? 연산자의 첫번째 피연산자는 항상 평가된다. 그리고나서 두번째 또는 세번째 피연산자가 평가된다.<br/>
&nbsp; - 콤마 연산자의 첫번째 피연산자는 평가되고 나서 두번째 피연산자가 평가된다.
<br/><br/>
참조 : 괄호의 우선순위는 연산자에 적용된 우선순위를 변형시킬 수 있다. 그러나 이는 순서에 평가된
가장 낮은 레벨의 피연산자의 평가 순서에는 영향을 미치지 않는다.</br></br>
표현식의 평가와 관련된 예측할수 없는 행동의 많은 경우는 [Rule 13.3]과 [Rule 13.4]를 준수함으로써 피할 수 있다

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Dir 4.9, Rule 13.0, Rule 13.3, Rule 13.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_03</rule>
		<ruleTitle><![CDATA[증감 연산자(++, --)를 포함한 수식은 해당 증감 연산자를 제외한 잠재적인 side effect 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

다른 연산자와 혼합된 증감연산자의 사용은 다음의 이유로 추천하지 않는다:</br></br>
&nbsp; - 코드의 가독성을 매우 해칠 수 있다.</br>
&nbsp; - 정의되지 않는 행동에 대한 잠재적인 구문의 추가적인 side effect의 가능성이 있다.</br></br>
다른 연산자와는 고립되게 증감 연산자를 사용하는 것이 좀 더 명확하다.</br></br>

<b>이 규칙에서 함수 호출은 side effect로 간주한다.</b></br></br>
모든 full 표현식의 하위 표현식은 그 하위 표현식이 표준에 의해 평가되지 않는 것으로 분류되더라도 이 규칙에 한해서 평가된 것 처럼 다뤄져야 한다.</br></br>

<span style="color:#B73232">See also</span>&nbsp;Rule 13.2</br>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[미사용 코드]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_01</rule>
		<ruleTitle><![CDATA[초기화 리스트가 영구적인 side effect을 일으키면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C99</br></br>

C90 표준은 aggregate 타입 객체의 초기화문이 상수표현식만 포함하도록 제한한다. 하지만 C99 는 aggregate 초기화문에 run-time에서 평가되는 표현식을 포함하는 것을 허용한다. 또한 초기화된 객체 처럼 동작하는 복합 리터럴의 경우도 혀용한다. 초기화 리스트에서 표현식의 평가 도중 side effects 가 발생하는 경우 그 순서는 명확하지 않으며, side effects가 영구적이라면  초기화의 동작은 예측할 수 없다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 13.2<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_06</rule>
		<ruleTitle><![CDATA[sizeof의 피연산자에 side effect를 발생시킬 수 있는 수식 포함 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

sizeof의 피연산자 내의 모든 표현식은 보통 평가되지 않는다. 이 규칙은 실제로 평가되는지와는 상관없이 어떤 표현식의 평가도 side effect를 포함하지 않을 것은 요구한다.
 <br/><br/>

sizeof의 피연산자는 표현식이거나 타입일 수도 있다. 피연산자가 표현식을 포함한다면, 가능한 프로그래밍 오류는 표현식이 대부분 상황에서 실제로 평가되지 않을 때 평가 받기를 기대하는 것이다. <br/><br/>
C90 표준에서는 피연산자의 표현식이 런타임에서 평가되지 않는다고 서술한다.<br/>
C99 표준에서는 피연산자의 표현식은 보통 런타임에서 평가되지 않는다. 하지만 피연산자가 가변 길이의 배열타입을 포함하면, 크기 표현식이 평가되어야 한다. 만약 배열크기 표현식의 평가없이 결과가 결정된다면 명시되지 않은 상황이다.
<br/><br/>
<b>이 규칙에서 함수의 호출은 side effect로 간주한다.</b>

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 18.8</br>]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_05</rule>
		<ruleTitle><![CDATA[사용되지 않은 매크로 선언은 없어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
매크로가 선언되었지만 사용되지 않는다면, 이는 여분으로 남겨둔건지 아니면 실수로 사용되지 않은 채로 남아있는 것인지 리뷰어에게 명확하지 않으므로 삭제하는 것을 권장한다.<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_04</rule>
		<ruleTitle><![CDATA[사용되지 않은 tag(struct, union, enum) 선언은 없어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
C 표준에서 struct, union, enum을 tag라고 부른다.<br/>
tag가 선언되었지만 사용되지 않는다면, 이는 여분으로 남겨둔 건지 아니면 실수로 사용되지 않는 채로 남아 있는 것인지 리뷰어에게 명확하지 않으므로 삭제하는 것을 권장한다.<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_03</rule>
		<ruleTitle><![CDATA[사용되지 않은 타입 선언은 없어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
선언된 타입이 사용되지 않으면, 타입이 쓸모가 있는지 아니면 실수로 남겨졌는지 명확하지 않다. 따라서, 사용되지 않은 타입은 삭제하는 것이 좋다.<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_02</rule>
		<ruleTitle><![CDATA[죽은 코드(dead code)는 없어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
실행 가능하지만 제거하더라도 프로그램의 동작에 영향을 주지 않는 모든 연산을 죽은 코드(dead code)라고 한다. 언어 확장에 의한 연산은 항상 프로그램 동작에 영향이 있다고 가정해서 죽은 코드로 보지 않는다.<br/>
참고로 Rule 2.1에서 언급한 도달할 수 없는 코드는 실행될 수 없기 때문에 죽은 코드는 아니다.<br/>
죽은 코드가 있다는 것은 프로그램 로직에 오류가 존재할 가능성을 암시한다. 이런 코드들은 컴파일러에 의해 삭제될 수 있으므로, 남겨 두면 혼란을 야기할 수 있으므로 삭제를 권장한다.<br/>
단, void로의 변환은 의도적으로 사용되지 않는 값을 가리킨다. 그러므로 void로의 변환 자체는 죽은 코드가 아니며, 그 피연산자를 사용하도록 하는 것 또한 죽은 코드가 아니다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 17.7<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_01</rule>
		<ruleTitle><![CDATA[도달할 수 없는 코드(unreachable code)가 있으면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
프로그램에서 undefined behaviour가 발생하지 않는 한, 도달할 수 없는 코드는 실행될 수 없고, 프로그램의 결과에 어떤 영향도 줄 수 없다. 따라서 도달할 수 없는 코드가 존재한다는 것은 프로그램 로직에 오류가 존재할 가능성이 있음을 의미하므로 삭제하는 것을 권장한다.<br/><br/>
컴파일러들은 도달할 수 없는 코드들을 삭제할 수 있다. 단, 다음과 같이 컴파일러가 바이너리를 생성하는 동작에 영향을 주는 코드는 삭제하지 않는다. 이 규칙에서도 이런 의도가 포함된 코드는 위배로 보지 않는다.<br/>
- 타겟 머신의 메모리를 차지한다.<br/>
- 컴파일러가 도달할 수 없는 코드 주위의 소스코드를 번역할 때, 더 길고 느린 점프 명령어를 선택하도록 한다.<br/>
- 루프 내에서, 도달할 수 없는 코드는 전체 루프가 캐쉬 내에 상주하는 것을 방해한다.<br/><br/>
또한 예외 상황을 처리하기 위한 방어 코드가 도달할 수 없는 코드가 되는 경우가 있다. 예를 들어, Rule 16.4를 준수하기 위해 switch에는 항상 default가 존재해야 한다. 모든 도달 가능한 값들을 처리할 수 있는 case가 존재하더라도 default를 넣는 이유는, 프로그램 내의 undefined behaviour 혹은 하드웨어 고장으로 인해 발생할 수 있는 예외적인 값들을 처리하기 위해서이다. 이런 방어 코드는 이 규칙에서 위배로 검출하지 않는다.<br/>
어떤 컴파일러는 default가 도달 불가능한지를 분석하여 삭제하기도 한다. 그러나 반드시 default 방어 코드가 필요한 경우, volatile을 이용하여 컴파일러가 삭제하지 않도록 할 수 있다. switch (*(volatile uint16_t*)&x)와 같이 작성하면 컴파일러는 이 조건식에는 어떤 값도 들어올 수 있다고 가정하므로, default가 삭제되지 않는다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 14.3, Rule 16.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_07</rule>
		<ruleTitle><![CDATA[함수에서 사용되지 않은 파라미터는 없어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
만일 함수 파라미터가 사용되지 않으면, 함수의 구현과 그 명세 내용이 맞지 않을 가능성이 있다. 이 규칙은 이러한 잠재적인 불일치를 방지하기 위한 가이드라인이다.<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_06</rule>
		<ruleTitle><![CDATA[함수 내에 사용되지 않은 레이블(label) 선언은 없어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
레이블이 선언되었지만 사용되지 않는다면, 이는 여분으로 남겨둔건지 아니면 실수로 사용되지 않은 채로 남아있는 것인지 리뷰어에게 명확하지 않으므로 삭제하는 것을 권장한다.<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_04_01</rule>
		<ruleTitle><![CDATA[8진수, 16진수 escape 시퀀스에 다른 escape 시퀀스 외에는 붙이면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
8진수 또는 16진수 escape 시퀀스 뒤에 다른 문자열이 붙으면 혼동이 올 수 있다. 따라서 escape 시퀀스끼리만 붙여 사용하는 것이 좋다.<br/>
예를 들어, 문자 상수 '\x1f'는 하나의 문자로 구성되어 있지만, 문자 상수 '\x1g'는 두 문자 'x1' 과 'g'로 구성되어 있다.<br/>
모든 8진수 또는 16진수 escape 시퀀스들을 "\x41g" 대신 "\x41" "g"처럼 별도의 문자열 상수로 끊어서 기록하면 혼동의 가능성은 줄어든다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;C90: Section 6.1.3.4, C99: Section 6.4.4.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_04_02</rule>
		<ruleTitle><![CDATA[Trigraph는 사용하면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
Trigraph는 두 개의 물음표 뒤에 문자가 하나 더 붙어서 만들어진다. 예를 들어, '??- '는 '~' 를, '??)'는 ']'를 나타낸다.<br/>
이들은 다른 의미로 두 개의 물음표를 사용했을 때 의도치 않게 혼동을 가져온다.<br/>
예를 들어,<br/>
"(Date should be in the form ??-??-??)"<br/>
이 문자열을 trigraph로 처리하면,<br/>
"(Date should be in the form ~~]"<br/>
이렇게 처리된다.<br/>
대부분의 컴파일러들은 trigraph를 옵션 처리하여 위의 ??-??-?? 문자열을 trigraph로 처리하지 않고 있는 그대로 해석할 수 있다. 컴파일러에 따라 기본 동작이 차이가 날 수 있으므로, 가능한 trigraph로 해석될 수 있는 문자열은 사용하지 않는 것이 좋다.<br/><br/>
참고로 다음을 digraph라고 한다:<br/>
<: &nbsp;:> &nbsp;<%&nbsp; %>&nbsp; %: &nbsp; %:%:</br>
위와 같은 digraph는 token이기 때문에 허용한다.<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

개발자가 반복문이나 선택문의 몸체를 괄호없이 문장만을 나열하는 것이 들여쓰기에 장점이 있다고 믿는 경우가 있다. 실수로 제어 표현식 다음에 ";" 이 포함되면 null 문장으로 연결되므로 위험하다. 복합문을 사용해야 반복문이나 선택문의 몸체를 분명하게 정의할 수 있다.
</br>게다가 개발자가 엉뚱한 if 문과 else 문을 연결해서 읽을 수도 있다.</br></br>

<b>예외사항</b></br></br>

<b>else if</b> 는 <b>else</b> 의 몸체를 복합문으로 해서 if 문을 쓰는 형태가 아니어도 된다.
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_07</rule>
		<ruleTitle><![CDATA[모든 if ... else if 구조는 else 문으로 끝나는지 검사]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

if 문에 뒤 따르는 else if 문이 하나라도 있으면 반드시 else 문으로 끝나야 한다.
if ... else if 구조를 else 문으로 끝내는 것은 방어적인 프로그래밍이고 switch 문에 default 절을 사용하는 이유를 보완한다.([Rule 16.5] 참고)</br></br>
else 문은 side effect 가 있거나 코드 리뷰를 위한 지시나 원하는 동작 등을 주석으로 표현해야 한다.</br></br>
참조: 단순한 if 문에는 else 문이 필요하지 않다.


<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.5<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_04</rule>
		<ruleTitle><![CDATA[반복문에는 하나의 break 나 goto 문만 있는지 검사]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

반복문의 출구를 제한하면 코드가 복잡하지 않다. 하나의 break 나 goto 문을 허용하면 반복문이 조건식 보다 더 일찍 종료되는 경우가 하나가 된다

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 15.1, Rule 15.2, Rule 15.3<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_05</rule>
		<ruleTitle><![CDATA[함수는 마지막에 하나의 return만 가지는지 검사]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

IEC 61508 과 ISO 61508 에서는 모듈식 접근을 위해 하나의 출구만 요구하고 있다. <br/>
함수 중간의 return 은 의도하지 않게 함수 종료 코드의 누락을 발생시킨다.
함수의 출구가 계속해서 side effect를 발생하는 문장들과 배치되어 있다면,  함수가 실행될 때 어떤 side effect 가 발생할지 알기가 힘들다.<br/><br/>

<b>함수는 하나의 return 문만 가져야 한다.<br/>
return 문은 함수의 몸체의 마지막 문장이어야 한다.</b>

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 17.4<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_02</rule>
		<ruleTitle><![CDATA[goto 문의 label이 같은 함수에서 더 나중에 위치하는지 검사]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

goto 를 무분별하게 사용하면 프로그램이 체계가 없고 이해하기가 너무 어렵다.
</br>
goto 문으로 <b>뒤로</b> 돌아가는 것을 금지해야 한다. 같은 코드를 재수행 해야 할 때는, 언어에서 제공하는 반복문을 사용하여 코드가 복잡해지는 것을 막을 수 있다. <br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 15.1, Rule 15.3, Rule 15.4</br>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_03</rule>
		<ruleTitle><![CDATA[goto 문이 참조하는 label은 같은 블록이나 인접한 블록에 있는지 검사]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

goto 를 무분별하게 사용하면 프로그램이 체계가 없고 이해하기가 너무 어렵다.
블록 사이나 내부 블록으로 뛰지(jump) 않도록 하면,  코드가 복잡해지는 것을 막을 수 있다. 
<br/><br/>
참조: C99 에서는 변하기 쉬운 타입을 사용할 때 더 많은 제약이 있다. 변하기 쉬운 타입인 식별자가 있는 내부 scope 로 뛰려고 시도하는 것은 제약을 위배하는 것이다.<br/><br/>

<b>이 규칙에서 복합문으로 이루어지지 않은 switch 절은 블록으로 취급한다. </b>
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 9.1, Rule 15.1, Rule 15.2, Rule 15.4, Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_01</rule>
		<ruleTitle><![CDATA[goto 문 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

goto 를 무분별하게 사용하면 프로그램이 체계가 없고 이해하기가 너무 어렵다.
goto를 사용하지 않으면 올바른 제어 흐름을 위해 flag를 도입해야 하고, flag를 사용하면 goto를 사용한 것보다 명료하지 못한 경우가 있다.</br></br>
따라서 이 규칙을 따르지 않는다면, [Rule 15.2] 와 [Rule 15.3] 의 가이드라인을 따라 goto 를 제한적으로 사용해야 한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 9.1, Rule 15.2, Rule 15.3, Rule 15.4</br>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_01</rule>
		<ruleTitle><![CDATA[포인터의 연산 결과는 해당 포인터가 가리키는 배열의 요소이어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
몇몇 컴파일러는 컴파일 타임에 배열의 범위가 초과되었는지 알 수 있지만, 일반적으로 런타임 시점에서 유효하지 않은 배열에 대해서 확인하지 않는다. 유효하지 않은 배열을 사용하면 프로그램에서 오류가 발생할 수 있다.<br/><br/>
런타임에 결정되는 배열 값들은 정적 분석이나 수작업 검토에 의해 쉽게 확인할 수 없기 때문에 문제가 발생하기 쉽다. 어떤 값이 유효한지 확인하고 필요하다면 적절한 동작을 추가하기 위해서 가능한한 방어적인 프로그래밍 코드가 제공되어야 한다.<br/><br/>
상위 표현식의 하나로 부터 얻어진 결과가 pointer_expression에 의해 가리키는 배열의 요소가 아니거나, 배열의 끝에서 1이상 넘어간 요소라면, 이것은 정의되지 않은 행동이다. C90의 6.3.6과 C99의 6.5.6을 참고하라.<br/><br/>
다차원 배열은 "배열의 배열" 이다. 이 규칙은 다른 하위 배열의 주소를 가리키는 포인터를 만들 수 있는 포인터 연산을 금지한다. 내부 범위를 벗어나는 배열 또한 사용하면 안된다.<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Dir 4.1,&nbsp;Rule 18.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_02</rule>
		<ruleTitle><![CDATA[포인터 간의 뺄셈은 같은 배열의 요소들을 가리키고 있는 포인터들에만 적용되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
이 규칙은 표현식의 형태에 적용한다:<br/><br/>
<b>pointer_expression_1 - pointer_expression_2</b><br/><br/>
위의 표현식에서 pointer_expression_1과 pointer_expression_2가 같은 배열의 요소를 가리키지 않거나, 배열의 끝보다 1 뒤에 위치한 요소를 가리키는 경우 정의되지 않은 행동을 할 수 있다.<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Dir 4.1,&nbsp;Rule 18.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_08</rule>
		<ruleTitle><![CDATA[Variable-length(길이를 변수로 지정한) 배열 타입 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
Variable-length 배열 타입은 블록이나 함수 프로토타입에 선언된 배열의 크기가 상수가 아닐 때 명시된다. 이는 스택에 저장된 변수 길이의 객체로 구현된다. 그러므로 이러한 사용은 스택에 할당되어야 할 메모리 양을 정적으로 결정할 수 없게 만든다.<br/><br/>
Variable-length 배열의 사이즈가 0이거나 음수이면, 정의되지 않은 행동을 할 수 있다.<br/><br/>
Variable-length 배열이 호환되어야하는 다른 배열 타입의 컨텍스트에 사용된다면, 배열 타입의 크기는 동일해야 한다. 또한 모든 크기는 양수로 평가되어야한다. 이러한 요구사항들이 충족되지 못한다면, 정의되지 않은 행동을 할 수 있다.<br/><br/>
Variable-length 배열이 sizeof 연산자의 피연산자로 사용된다면, 어떤 상황에서는 배열 크기를 나타내는 표현식이 평가되는지 아닌지 명확하지 않다.<br/><br/>
각각의 Variable-length 배열 타입은 그 수명이 시작될 때 고정된 크기를 가진다. 이러한 행동은 다음과 같이 혼란스러울 수 있다.<br/><br/>
<textarea id="ex1" >
void f ( int_16_t n )
{
	uint16_t vla[ n ];		/* Not-compliant - Undefined if n <= 0 */
}

void g ( void )
{
	f ( 0 );	/* Undefined */
	f ( -1 );	/* Undefined */
	f ( 10 );	/* Defined */
}

void h ( uint16_t n, uint16_t a[ 10 ][ n ] )		/* Non-compliant */
{
	uint16_t ( *p )[ 20 ];
	/* Undefined unless n == 20: incompatible types otherwise */
	p = a;
}
</textarea>
<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 13.6<br/>
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_07</rule>
		<ruleTitle><![CDATA[구조체의 멤버로써 가변 배열 선언금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
가변길이의 배열 멤버는 Dir 4.12와 Rule 21.3에서 금지된 동적 메모리 할당과 함께 사용될 수 있다.<br/><br/>
가변길이 배열은 sizeof 연산자의 행동을 개발자가 기대하지 않는 방향으로 변형시킨다. 가변길이 배열을 포함하는 구조체의 같은 타입의 다른 구조체로의 할당은 예상과는 다르게, 가변 길이 배열 멤버의 시작주소를 제외하고 다른 요소들만 복사할 것이다.
가변 길이 배열을 포함하는 구조체에서, 같은 타입의 다른 구조체로의 할당은 기대한 대로 행동하지 않는다. 왜냐하면 복사가 일어날 때 다른 요소들은 복사되지만, 가변 길이 배열의 주소는 복사되지 않기 때문이다.<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Dir 4.12,&nbsp;Rule 21.3<br/>
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_06</rule>
		<ruleTitle><![CDATA[자동으로 값이 할당되는 객체의 주소는, 처음 객체가 소멸된 이후에도 지속되는 다른 객체로 복사 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
객체의 주소는 다음과 같은 상황에서 복사된다:<br/>
  - 할당<br/>
  - 메모리 이동 또는 복사 함수<br/><br/>
객체의 수명이 끝났을 때 그 객체의 주소는 불확실하다. 불확실한 주소를 사용하면 정의되지 않은 행동을 할 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_05</rule>
		<ruleTitle><![CDATA[3차원 이상의 포인터 선언 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
3차원 이상의 포인터 사용은 코드의 가독성을 심각하게 손상시킬 수 있으므로, 이는 피해야 한다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
ptr[expr]과 같이 배열에 사용하는 인덱싱 형태는 포인터 산술연산의 선호되는 형태이다. 이는 명확하고 이로 인해 포인터 조작보다 에러가 적기 때문이다. 포인터 값을 명시적으로 계산하는 것은 의도하지 않거나 잘못된 메모리에 접근할 수 있어서 잠재적인 위험을 가지고 있다. 이러한 행동은 배열 인덱싱을 통해서도 가능하고, 또한 배열 인덱싱을 사용할 경우 리뷰 작업 또한 쉽게 할 수 있을 것이다.<br/><br/>
C 언어에서의 포인터 산술연산은 초심자에게 혼란을 줄 수 있다. 표현식 'ptr + 1'은 ptr의 주소에 1을 더하는 것으로 잘못 해석될 수 있다. 사실 새 메모리 주소는 포인터가 가리키는 대상의 크기에 의존한다. 이러한 오해로 인해 sizeof 연산자가 잘못 적용되었을 때 기대하지 않은 행동을 할 수 있다.<br/><br/>
하지만 주의해서 사용했을 때 ++를 사용한 포인터 조작은 몇몇 경우에서 더 자연스러울 수 있다. 예를 들면, 메모리 테스트를 하는 동안 연속적으로 어떤 위치에 접근해야할 때, 즉, 연속적인 위치의 집합으로 이루어진 메모리 공간을 다룰 때, 컴파일 타임에 결정되는 주소 범위를 다룰 때 더욱 편리하다.<br/><br/>

<b>예외사항</b>: 규칙 18.2의 두 포인터 간의 차감 연산은 허용한다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 18.1,&nbsp;Rule 18.2<br/>
]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_03</rule>
		<ruleTitle><![CDATA[관계 연산자 >, >=, <, 그리고 <=는 같은 객체를 가리키고 있는 포인터를 제외한 다른 포인터 타입의 객체에 적용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
포인터 간 비교를 시도하는 것은 두 포인터가 같은 객체를 가리키지 않는다면 정의되지 않은 행동을 발생시킨다.<br/><br/>
참조 : 배열의 끝보다 1 뒤에 위치한 요소의 주소를 가리키는 것은 허용하지만, 이 요소를 접근하는 것은 허용하지 않는다.<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Dir 4.1<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[기타]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_06_02</rule>
		<ruleTitle><![CDATA[single-bit로 표현된 이름있는 bit-field는 signed면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
C99 표준 Section 6.2.6.2에 따르면, single-bit signed bit-field는 부호 bit만 있고 값을 표현하는 bit이 없다. 이는 어떤 정수 값 표현에서도 의미있는 값이 아니다.<br/>
따라서 single-bit signed bit-field는 유용하게 사용될 가능성이 낮고, 개발자의 혼란을 야기시킨다.<br/>
C90 표준에서는 자세한 언급이 없으나, C99와 동일하게 적용 가능하다.<br/>
참고로 이름 없는 bit-field는 그 값에 접근할 수 없으므로 위배로 검출하지 않는다.<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_06_01</rule>
		<ruleTitle><![CDATA[bit-field는 올바른 타입으로 선언되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
올바른 bit-field 타입은 다음과 같다: <br/>
- C90 : unsigned int 또는 singed int<br/>
- C99 : 다음 중 하나:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* unsinged int 또는 singed int<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* 컴파일러가 제공하는 다른 명시적인 부호가 있는 integer 타입<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* _Bool<br/><br/>
int는 컴파일러에 따라 signed일 수도 있고 unsigned일 수도 있기 때문에 int를 사용하는 것은 컴파일러에 따라 다르다.<br/>
enum, short, char 나 다른 타입의 bit-field 는 C90에서 정의하지 않은 행동이므로 허용되지 않는다.<br/>
C99에서는 bit-field 선언에서 다른 integer 타입을 사용하는 것을 허용한다.<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_01</rule>
		<ruleTitle><![CDATA[stdarg.h에 정의된 요소들은 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

 <b>va_list, va_arg, va_start, va_end, va_copy</b> 는 사용하면 안 된다.</br></br>
 표준에는 "stdarg.h" 와 관련된 많은 정의하지 않은 행동을 나열하고 있다:</br></br>
	- va_start 를 사용한 함수에서 va_end 를 사용하지 않는 경우</br>
	- 같은 va_list 의 va_arg 를 서로 다른 함수에서 사용하는 경우</br>
	- 함수의 인자의 타입과 va_arg 에 명시한 타입이  맞지 않는 경우]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_05</rule>
		<ruleTitle><![CDATA[배열 타입으로 선언된 함수의 매개변수는 적합한 수의 원소를 가져야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

함수의 매개변수가 특정한 크기의 배열로 선언되면, 함수 호출마다 해당하는 인자의 배열은 원소의 수가 일치해야 한다. 함수의 매개변수에 배열을 사용하면 포인터를 사용하는 것보다 명확하다. 포인터와는 다르게 함수에서 바라는 최소한의 원소의 수를 명시적으로 보여 줄 수 있다.</br></br>
함수의 매개변수에 배열의 크기를 명시하지 원소의 크기가 얼마이든 상관 없다는 뜻이다.  이런 경우에는 배열의 크기를 다른 인자로 결정하거나, 배열의 원소가 특정 값인지 검사하여 반복문을 종료한다.</br></br>
함수에서 매개변수로 전달 받은 배열의 경계를 검사하는 것만큼이나, 배열의 경계를 명시해 주는 것도 중요하다. C 에서는 크기를 명시한 매개변수와 맞지 않은 크기의 배열을 사용하는 것을 허용하지만, 예상하지 못한 동작을 일으킬 수 있다.   
 
 ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_04</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 모든 경로의 마지막은 수식을 포함한 return 문이어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

return 문의 표현식은 함수가 반환하는 값을 나타낸다. void 가 아닌 함수가 반환 값이 없으면, 정의하지 않은 행동이다.</br>

&nbsp;	- 모든 return 문에 표현식이 있다.</br>
&nbsp;	- 함수의 제어 흐름이 return 문으로 끝난다.</br></br>

 참조: C99 에서 void 가 아닌 함수의 모든 return 문은 값을 반환해야 한다.]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_03</rule>
		<ruleTitle><![CDATA[함수를 묵시적으로 선언 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90<br/><br/>

함수 호출은 프로토 타입에 따라야 한다. 함수 호출의 인자 수와 타입이 일치해야 한다.<br/><br/>
만약 함수를 묵시적으로 선언하면, C90 컴파일러는 함수의 반환 타입을 int 로 간주한다. 묵시적인 함수는 프로토 타입을 제공하지 않기 때문에, 컴파일러는 함수의 인자나 타입의 정보를 알 수 없다. 인자와 반환 값의 타입이 부적절하게 변환되고, 다른 정의하지 않은 행동도 발생할 수 있다.    ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_02</rule>
		<ruleTitle><![CDATA[직, 간접적 재귀호출 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

재귀는 스택 공간을 넘치게 하여, 심각한 오류가 발생할 수 있다. 재귀를 아주 엄격하게 관리해도, 실행 전에 스택 공간에서 오류가 발생 할 수 있는 상태를 측정할 수는 없다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

함수의 매개변수는 auto 객체와 같이 행동한다. C 언어에서 매개변수를 변경하는 것을 허용한다. 하지만 이런 행동은 프로그래머에게 혼란을 줄 수있고,  프로그래머가 기대하는 것과 일치하지 않을 수 있다. 파라미터를 auto 객체에 복사하여 변경하면 혼란을 줄일 수 있다. 최신의 컴파일러에서는 이렇게 해도 저장 공간이나 컴파일 시간에서 손해가 없다.</br></br>
 C 에 익숙하지 않지만 다른 언어를 사용해본 프로그래머라면, 해당 함수를 호출할 때 수정한 파라미터가 영향을 줄 것이라고 생각할 수 있다.  ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

호출한 함수의 반환 값을 사용하지 않으면, 오류가 발생할 수 있다. 함수의 반환 값을 의도적으로 사용하지 않으면, void 로 캐스팅해야 한다. 이렇게 하면 [Rule 2.2] 를 위반하지 않고 값을 사용할 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_06</rule>
		<ruleTitle><![CDATA[배열 타입의 매개 변수의 선언은 [] 사이에 static keyword를 포함하지 않아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>

C99 표준에서는 프로그래머가 컴파일러에게 배열 타입의 파라미터의 원소 개수를 특정 할 수 있는 장치를 제공한다. 어떤 컴파일러는 이 정보를 이용하여 효과적으로 코드를 생성할 수 있다. <br/><br/>
프로그래머가 허용 값을 명시하는 것이 허용되지 않고, 원소의 수가 명시한 것보다 적으면, 정의하지 않은 행동이다.<br/><br/> 
 임베디드 프로그램에서 사용하는 프로세서는 프로그래머가 제공하는 정보를 이해하지 못 할 수 있다. 성능의 향상을 위해 사용한 한정 값 때문에 프로그램이 실패할 수  있다.    ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_01</rule>
		<ruleTitle><![CDATA[타입은 명시적으로 입력해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90<br><br>

 C90 표준은 상황에 따라 타입을 명시하지 않아도 int 타입으로 인식한다. 이러한 상황의 예로는 다음이 있다.</br></br>
- 객체 선언</br>
- 파라미터 선언</br>
- 멤버 선언</br>
- typedef 선언</br>
- 함수 반환 타입</br></br>
명시적으로 타입을 입력하지 않으면 혼란을 줄 수 있다. 예를 들어, 다음의 선언</br></br>
extern void g ( char c, <b>const k</b> );</br></br>
에서 <b>k</b>의 타입은 <b>const char</b>를 기대하는 것과는 달리 <b>const int</b> 이다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.2<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[함수는 이름 있는 파라미터로 구성된 프로토타입 형태여야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

인자(argument)와 매개변수(parameter) 간의 타입, 그리고 함수의 리턴 타입과 실제 리턴 타입의 불일치는 정의되지 않은 결과를 발생시킨다. <br/><br/>

이 규칙과 [MISRA_C_2012_08_01], [MISRA_C_2012_08_04] 의 목적은 매개변수 타입과 함수 리턴 타입을 명시적으로 입력해서 이러한 미정의된 특성을 피하는 것이다.</br></br>

또한, 이 규칙은 선언 시에 모든 매개변수의 이름을 명시하도록 요구한다. 매개변수의 이름은 함수 인터페이스에 관한 정보를 제공할 수 있고, 컴파일러가 선언과 정의간의 불일치와 관련된 경고를 출력할때, 더 자세한 정보를 제공할 수 있게 한다.</br></br>

참고: 함수의 파라메터가 없는 경우에 void 를 명시해야한다. C90/99 에서 <b>int f();</b> 의 의미는 함수 인자의 개수와 타입을 모르는 경우에 사용하고, <b>int f(void);</b> 는 인자가 없음을 의미한다. C++ 에서는 <b>int f();</b> 와 <b>int f(void);</b> 동일한 의미를 갖는다.<br/><br/>

관련 링크: <a href="http://david.tribble.com/text/cdiffs.htm#C99-empty-parm">http://david.tribble.com/text/cdiffs.htm#C99-empty-parm</a>

<br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.1, Rule 8.4, Rule 17.3<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_03</rule>
		<ruleTitle><![CDATA[동일한 객체 또는 함수의 모든 선언은 같은 이름과 타입 한정자를 사용해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

객체 또는 함수를 선언하거나 정의할 때, 타입과 한정자(const, volatile등)는 모든 선언과 정의에서 같아야 한다.</br></br>

함수 선언시에 파라미터 이름을 명시하면, 컴파일러에 의해 함수 정의와 함수 선언간의 인터페이스의 동일성을 검사할 수 있는 기회를 줄 수 있다.</br></br>

<b> 예외 : 같은 기본 타입이 호환 가능하면 아래 처럼 사용할 수 있다.</b>
<textarea id="ex1" >
    extern void f(signed int);
           void f(       int);   /* 타입 호환되므로 예외 */
    extern void g(int * const);
           void g(int *      );  /* 위배: 한정자 불일치  */           

</textarea>
<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script>
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.4<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_01</rule>
		<ruleTitle><![CDATA[소스코드에서 #include의 상단에는 전처리 지사자 또는 주석만 허용]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
코드의 가독성을 위해서, 특정 코드 파일의 모든 #include 지시자는 파일의 최상단 근처에 같이 모여 있어야 한다.
추가적으로, 선언이나 정의 내에 표준 헤더파일을 include 하기 위해 #include를 사용하거나
관련된 표준 헤더파일을 include 하기 전에 표준 라이브러리의 일부를 사용하는 것은 정의되지 않은 행동이다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_03</rule>
		<ruleTitle><![CDATA[#include 지시자는 <filename> 또는 "filename"의 형태를 따라야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
#include 지시자가 다음의 형태 중 하나를 사용하지 않는다면 정의되지 않은 행동이다.<br/><br/>
- #include <filename><br/>
- #include "filename"]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_05</rule>
		<ruleTitle><![CDATA[외부연결(external linkage)를 갖는 객체나 함수는 오직 하나의 파일에서만 선언되어야함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

이 규칙은 정의가 아닌 선언에만 적용된다.<br/><br/>

일반적으로 선언은 헤더파일에 있고, 이 헤더 파일을 각 코드파일(.c) 에서 포함하여 사용할 것이다. 이것은 다음의 일관성을 보장한다:<br/>
 - 선언과 정의<br/>
 - 다른 번역단위(translation unit)들 안에서의 선언<br/><br/>

참조: 프로젝트 내에 많은 헤더파일이 있지만 각각의 external 객체나 함수는 하나의 헤더파일에만 선언되어야 한다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.4<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_02</rule>
		<ruleTitle><![CDATA[문자 ', ", \ 와 문자열 /* , //은 헤더파일의 이름에 포함 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
다음의 경우 정의되지 않은 행동이다.<br/><br/>
- 문자 ',  ", \ 또는 문자열 /*, // 가 헤더이름 내에 < 과 > 사이에 사용됨<br/>
- 문자 ', \ 또는 문자열 /* , // 이 헤더이름 " 사이에 사용됨]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_04</rule>
		<ruleTitle><![CDATA[객체나 함수의 정의 또는 호출 이전에 호환가능한 선언이 존재해야함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

함수나 객체가 정의되었을 때 그 객체나 함수에 대한 선언이 있다면 컴파일러는 반드시 그 선언과 정의가 호환가능한지 확인한다. <br/><br/>

함수의 프로토타입은 [MISRA_C_2012_08_02] 의 요구에 따라 존재해야 하며, 컴파일러는 함수 파라메터의 타입과 파라메터의 개수까지 일치하는지 확대 적용된다.</br></br>

추천하는 방법은 external 연결을 갖는 객체나 함수선언들은 헤더파일 내에 위치 시킨 후, 해당 함수나 객체가 필요한 모든 코드파일(.c) 내에 해당 헤더파일(.h)을 포함(include)시켜 사용하도록 한다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.2, Rule 8.3, Rule 8.5, Rule 17.3<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_05</rule>
		<ruleTitle><![CDATA[#undef 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
#undef의 사용은 translation unit 내의 특정 지점에서 매크로가 존재하는지 불명확하게 한다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_07</rule>
		<ruleTitle><![CDATA[함수나 객체가 하나의 번역단위에서 참조된다면 외부참조(external linkage)로 정의되면 안됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

객체를 내부연결(internal linkage)로 정의하여 가시성을 제한하는 것은 실수로 접근될 가능성을 줄여준다.
유사하게 함수를 내부연결로 정의하여 가시성을 제한하는 것 또한 실수로 호출되는 가능성을 줄여준다.</br></br>
이 규칙을 준수하는 것은 다른 Translation Unit이나 라이브러리에서의 동일한 식별자 사이에 혼동의 가능성을 줄여준다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_04</rule>
		<ruleTitle><![CDATA[키워드와 같은 이름으로 매크로 정의 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
키워드의 의미를 바꾸기 위해 매크로를 사용하는 것은 혼란을 줄 수 있다.
키워드와 같은 이름인 매크로가 정의되어 있는 동안 해당 표준헤더가 include 되어 있다면 정의되지 않은 행동을 할 수 있다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 21.1<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_06</rule>
		<ruleTitle><![CDATA[외부연결 식별자는 하나의 외부정의(external definition)을 가져야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

여러 개의 정의를 가졌거나(각각 다른 파일 내에서) 정의가 존재하지 않으면 일반적으로 링킹시에 오류가 발생하며, 오류가 발생하지 않더라도 정의되지 않은 결과가 발생한다.<br/><br/>

각각 다른 파일 내에서의 동일한 식별자로 정의된 객체나 함수는 내용이 똑같다고 하더라도 허용되지 않는다(one definition rule 위반). 선언이 다르거나 초기화가 다르더라도 이는 정의되지 않은 결과를 발생시킨다.<br/><br/>

<b><font color="red">주의:</font></b> 이 결함은 하나의 인스펙터 프로젝트에 서로 다른 링크단위의 프로젝트를 같은 모듈 구성에 포함하는 경우에 발생할 수 있으며, 이 경우 잘못된 탐지가 발생 될 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_07</rule>
		<ruleTitle><![CDATA[매크로 인자는 괄호로 감싸야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
매크로 인자에 괄호가 사용되지 않는다면, 매크로로 치환할 때 연산자 우선순위가 원하는 결과로 나오지 않을 수 있다.
매크로 인자가 표현식으로 사용되지 않는다면, 어떠한 연산자도 포함되지 않기 때문에 괄호는 필요하지 않다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Dir 4.9<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_09</rule>
		<ruleTitle><![CDATA[단일 함수에만 쓰이는 객체는 해당 블록범위에서 정의되어야 한다.]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

함수 내에서 객체가 블록 밖에 정의되느냐 내부에 정의되느냐 하는 것은 코딩 스타일의 문제로, 블록 범위에 객체를 정의하는 것은 실수로 접근되는 것은 줄여주고 그 객체가 다른 곳에서 접근되지 말아야 한다는 의도를 명백히 한다.<br/><br/>

하지만, 이 규칙을 준수하는 것이 불가능한 상황이 있을수 있다. 예를들어, 블록 내부에 static 으로 선언된 객체는 외부에서 직접 접근할 수 없다. 이 경우 객체를 포인터를 이용하여 접근하는 방법을 사용할 수 있을텐데. 효과적이지 못하다. 이러한 상황에서는 이 규칙을 적용하지 않는 것을 더 좋을 수 있다.<br/><br/>

<b>이러한 경우,</b> "위배 무시하기" 기능이나 규칙모음에서 해당 규칙을 제외할 수 있다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_06</rule>
		<ruleTitle><![CDATA[매크로 인자 부분에 전처리 지시자 사용금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
만약 인자가 전처리 지시자 처럼 행동한다면, 매크로가 대체되었을 때 그 행동은 예측하지 못한 결과를 가져올 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_08</rule>
		<ruleTitle><![CDATA[내부 연결(internal linkage) 을 갖는 모든 객체 또는 함수는 static 을 이용해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

객체나 함수가 extern으로 선언되어있지만, 이전에 그 객체나 함수의 static 선언이 이미 있다면, 이 경우 extern 지정자가 외부연결을 생성하기때문에 혼란을 일으킬 수 있다. 그러므로 static 지정자는 내부연결을 가지는 함수와 객체에 일관성있게 적용되어야 한다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_09</rule>
		<ruleTitle><![CDATA[#if 또는 #elif의 제어 표현식에 사용된 모든 식별자는 평가하기 전에 #define으로 정의 되어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
전처리 지시자 내에서 매크로 식별자를 사용하기 위한 시도가 있다면, 그리고 그 식별자가 정의되지 않았다면, 전저리기는 그 값을 0으로 가정할 것이다. 이것은 개발자의 예상과는 다를 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_08</rule>
		<ruleTitle><![CDATA[#if 또는 #elif의 제어 표현식은 0 또는 1로 값이 나와야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
Strong typing(컴파일 타임에 최대한 많은 타입 체크를 해주는)은 Boolean 값을 갖기 위해, 조건을 포함하는 전처리 지시자로 이루어진 제어 표현식을 요구한다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 14.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

이 규칙을 준수하는 것은 프로그램 실수로 인해 포인터를 통해 객체의 상태를 변형하지 못하도록 보증하는 최선의 방법이다.</br></br>

다음과 같은 상황은 제외한다.</br></br>
 - 객체를 변형하기 위해 사용</br>
 - 아래에 해당하는 것을 이용하여 const 가 아닌 타입을 가리키는 또 다른 포인터를 복사할때</br>
&nbsp;&nbsp;&nbsp;&nbsp;+ 할당</br>
&nbsp;&nbsp;&nbsp;&nbsp;+ 메모리 이동 또는 함수 복사</br></br>

이 규칙은 포인터와 포인터가 가리키는 타입에 관하여 설명하나, 배열과 배열이 포함하는 요소의 타입에 대해서 동일하게 적용된다.
다음의 경우를 제외하면 배열은 const 인 요소들을 가져야 한다.</br></br>
 - 배열의 요소를 변형</br>
 - 위에 해당하는 것을 이용하여  const 가 아닌 타입을 가리키는 또 다른 포인터를 복사할때</br></br>

]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[기타]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_14</rule>
		<ruleTitle><![CDATA[restrict 사용금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

restrict 한정자는 포인터에 쓸 수 있으며, restrict 가 붙은 포인터가 참조하는 데이터는 이 포인터로만 접근이 가능하고 다른 포인터는 접근이 불가능하다.
이 키워드는 컴파일러로 하여금 이 포인터는 다른 포인터를 통해 변경되지 않는다는 걸 전제로하여 최적화를 수행할 수 있게 해준다.
하지만 restrict타입을 사용하기 위해 개발자는 메모리 영역에서 두개 이상의 포인터가 중복되지 않음을 반드시 보장 하여야한다.</br></br>
만약, 개발자가 restrict 에 대한 의미를 정확하게 보장되지 않는다면, 컴파일러는 임의로 최적화를 시도할 것이고, 이로인해 기대하지 않는 코드(코드의 순서를 임의로 변경 등)를 생성할 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_11</rule>
		<ruleTitle><![CDATA[배열에 대한 외부연결(external linkage) 선언 시, 그 크기를 명시적으로 해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

비록 불완전한 타입으로 배열을 선언하고 요소들에 접근하는 것이 가능하다고 하더라도, 배열의 크기가 명시적으로 기술되어 있을때 더 안전하다.
각 선언마다 크기를 명시적으로 지정하는 것은 그 배열들이 바르게 사용되고 있는지를 일관성있게 확인할 수 있도록 해준다. 또한 정적분석기가 한 개 이상의 컴파일 단위(translation unit)을 분석할 필요 없이
배열범위 분석을 할수 있게 해준다.<br/><br/>

<b>이 규칙은 전역변수 배열 선언에만 적용된다.</b>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_12</rule>
		<ruleTitle><![CDATA[열거자 리스트 내에서 묵시적으로 지정된 열거형 상수의 값은 유일해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

묵시적으로 지정된 열거형 상수는 바로 직전 열거형 상수 보다 1 큰 값을 가진다. 만약 첫번째 열거형 상수의 값이 묵시적으로 지정되었다면 그 값은 0이다.</br></br>
명시적으로 지정된 열거형 상수는 지정된 값을 그대로 가진다. 만약, 묵시적인 열겨형 상수와 명시적인 열거형 상수가 섞여있다면 그 값이 중복되는 것이 가능하다. 보통의 경우 이러한 중복은 코드 수정에 따른 의도하지 않은 것일 수 있고, 이로 인해 프로그램이 기대하지 않은 행동을 발생시킬수 있다.</br></br>
이 규칙은 열거형 상수값의 복제가 명시적으로 이루어 지는 것을 요구하며 이로 인해 그 의도를 명백히 하려 함에 목적이 있다.
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_10</rule>
		<ruleTitle><![CDATA[인라인 함수는 static으로 선언되어야 한다.]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

인라인 함수가 외부 연결로 선언되었지만 같은 컴파일단위(translation unit)내에 정의되어있지 않다면 결과는 정의되지 않은 행동을 유발한다.<br/><br/>

외부 연결로 선언된 인라인 함수 호출시, 내부 인라인 함수정의를 사용하거나, 외부함수를 호출할 수도 있다. 비록  이것이 함수호출 자체에는 영향이 없다고 하더라도,
리얼타임 프로그램을 실행할때 미묘한 타이밍에 영향을 미칠것이다.<br/><br/>

<b>참고</b> 인라인 함수가 여러 컴파일 단위에서 사용된다면, 정의를 헤더파일에 위치시킬 수 있다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 5.9<br>
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_12</rule>
		<ruleTitle><![CDATA[# 또는 ## 의 피연산자이며 추가적인 매크로 치환이 필요한 매크로 인자는 다른 연산자의 피연산자로 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
# 또는 ## 의 피연산자로 사용된 매크로 인자는 사용되기 전에 확장되지 않는다. 하지만 이 매크로 인자가 다른 곳에서 쓰일 경우에는 확장된다. 
 매크로 인자가 추가적인 매크로 치환이 필요하다면, 매크로 치환 내 혼합된 문맥은 개발자의 예상과 다를 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_11</rule>
		<ruleTitle><![CDATA[전처리 연산자 #의 피연산자 바로 뒤에 ## 연산자 사용금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
복수의 #, 복수의 ## 또는 # 과 ##의 혼합된 연산자가 사용된 표현식의 평가순서는 표준에 명시되지 않았다. 
#과 ##의 사용은 규칙 20.10에서 금지한다. 특정 상황에서 # 연산자의 결과는 string literal이고 이것을 다른 전처리 토큰에 붙여넣는 것이 유효한 토큰이 될 것이라고 보장할 수 없다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 20.10<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_10</rule>
		<ruleTitle><![CDATA[전처리 연산자 # 과 ## 사용금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
복수의 #, 복수의 ## 또는 # 과 ##의 혼합된 연산자가 사용된 표현식의 평가 순서는 표준에 명시되지 않았다.
그러므로 특정한 경우 매크로 확장의 결과를 예측하는 것은 불가능하다. ## 연산자의 사용은 코드를 모호하게 만들 수 있다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 20.11<br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_14</rule>
		<ruleTitle><![CDATA[모든 #else, #elif, #endif 전처리 지시자는 같은 파일 내에 관련된 #if, #ifdef, #ifndef 가 존재해야 한다.]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
조건부 컴파일 지시자가 여러 파일에 걸쳐서 사용됨으로써 코드 블럭이 포함되거나 제외된다면 이는 혼란을 불러일으킨다. #if 가 한 파일 내에서 종료되도록 요구하는 것은 코드의 시각적인 복잡도를 줄이고, 유지보수시 오류의 발생을 줄인다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_13</rule>
		<ruleTitle><![CDATA[첫번째 토큰이 # 인 행은 유효한 전처리 지시자여야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
전처리 지시자는 일치하는 #else, #elif, #endif와 만날때까지 소스코드를 제외시키는데 쓰일 수 있다. 제외된 코드 내 포함된 잘못된 전처리 지시자는 컴파일러에 의해 발견되지 못할 수 있고, 의도했던 것보다 더 많은 코드가 제외될 수 있다.
제외된 코드 내에서도 문법적으로 올바른 전처리 지시자를 사용하는 것은 이런 일이 발생하지 않도록 보장한다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_07</rule>
		<ruleTitle><![CDATA[복합 수식이 기본 산술 변환을 수행하는 연산자의 피연산자로 사용된 경우, 다른 피연산자는 해당 수식의 타입보다 큰 essential 타입을 가지지 않아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

복합 수식에 대한 묵시적 변환을 금지하는 것은 한 수식 내에 존재하는 산술 연산자들이 모두 같은 essential 타입으로 처리되어야 한다는 것을 의미한다. 이는 개발자의 혼동을 줄여준다.</br>
<b>참조</b> 이것이 한 수식의 모든 피연산자가 같은 essential 타입이어야 된다는 것을 의미하지 않는다는 점을 주의하라.</br></br>

수식 <b>u32a + u16a + u16c</b> 은 두 덧셈이 모두 uin32_t로 수행될 것이기 때문에 문제가 없다. 이 경우 비-복합 수식은 묵시적으로 형변환되었다.</br>
수식 <b>(u16a + u16b) + u32c</b> 의 좌측 덧셈은 uin16_t에서 수행되지만 우측 덧셈은 좌측 연산의 결과값을 uint32_t로 변환한 후 uint32_t에서 수행되기 때문에 문제가 있다. 

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.4, Rule 10.6, Section 8.10.3<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_08</rule>
		<ruleTitle><![CDATA[복합 수식의 값은 다른 essential 타입 분류에 속하는 타입이나 더 큰 essential 타입으로 변환되지 않아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

더 큰 타입으로의 변환은 각 구현체마다 결과가 상이하므로 허용되지 않는다. 아래의 경우를 고려해보자: <br/>

<textarea id="ex1">
(uint32_t) ( u16a + u16b );
</textarea>
<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script>

16비트 머신에서는 덧셈이 16비트 상에서 결과를 modulo-2로 처리하며 수행된 후 32비트로 변환된다. 그러나 32비트 머신에서는 덧셈 연산이 32비트상에서 수행되고 16비트 머신에서는 버려졌을 높은 자리수의 비트값들이 보존된다.
<br/><br/>
<b>같은 essential 타입 분류의 더 작은 타입으로의 변환은 명시적으로 결과값을 잘라내는 것은 항상 같은 정도(머신에 상관 없이)의 정보 손실을 일으키기 때문에 허용한다.</b>

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.5, Section 8.10.3<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

아래 표는 이 규칙의 정의를 위한 것이다.<br/><br/>

<center>
<table align="center" border="1" cellpadding="6">
<tr align="left">
<td rowspan="1">Description</td><td rowspan="1">Operator or Operand</td><td rowspan="1">Precedence</td>
</tr>

<tr align="left">
<td>Primary </td><td>identifier, constant, string literal, (expression)</td><td>16(high)</td>
</tr>

<tr align="left">
<td>Postfix</td><td>[] () (function call) , -> ++(post-increment) --(post-decrement) () {} (C99: compound literal)</td><td>14</td>
</tr>

<tr align="left">
<td>Unary</td><td>++(pre-increment) --(pre-decrement) & * + - ~ ! sizeof defined (preprocessor)</td><td>14</td>
</tr>

<tr align="left">
<td>Cast</td><td>()</td><td>13</td>
</tr>

<tr align="left">
<td>Multiplicative</td><td>* / %</td><td>12</td>
</tr>

<tr align="left">
<td>Additive</td><td>+ -</td><td>11</td>
</tr>

<tr align="left">
<td>Bitwise shift</td><td><< >></td><td>10</td>
</tr>

<tr align="left">
<td>Relational</td><td>< > <= >=</td><td>9</td>
</tr>

<tr align="left">
<td>Equality</td><td>== !=</td><td>8</td>
</tr>

<tr align="left">
<td>Bitwise And</td><td>&</td><td>7</td>
</tr>

<tr align="left">
<td>Bitwise XOR</td><td>^</td><td>6</td>
</tr>

<tr align="left">
<td>Bitwise OR</td><td>|</td><td>5</td>
</tr>

<tr align="left">
<td>Logical AND</td><td>&&</td><td>4</td>
</tr>

<tr align="left">
<td>Logical OR</td><td>||</td><td>3</td>
</tr>

<tr align="left">
<td>Conditional</td><td>?:</td><td>2</td>
</tr>

<tr align="left">
<td>Assignment</td><td>= *= /= %= += -= <<= >>= &= ^= !=</td><td>1</td>
</tr>

<tr align="left">
<td>Comma</td><td>,</td><td>0(low)</td>
</tr>

</table>
</center>
<p>
<br/><br/>
이 테이블에 사용된 우선순위는 규칙설명을 위한 것이다.
다른 연산자 우선순위 관련 테이블과 다를 수 있다.
표현식의 우선순위는 그 표현식의 파싱 트리 루트의 요소의 우선순위이다.
예를 들어 a << b + c 의 파싱 트리는 다음과 같이 표현된다.
파싱트리 루트의 요소는 "<<"이고 이 표현식은 우선순위 10 이다.<br/><br/>

<span style="font-family:Arial">
&nbsp;<<<br/>
&nbsp;/&nbsp;&nbsp;\<br/>
a&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;c<br/>
</span>
<br/><br/>

* sizeof의 피연산자는 괄호로 감싸져야 한다.<br/>
* 우선순위가 2-12의 표현식은 다음의 경우 괄호를 가져야 한다.<br/>
&nbsp;&nbsp;- 우선순위 13이하<br/>
&nbsp;&nbsp;- 표현식의 우선순위보다 클 때<br/>

C언어의 상대적으로 많은 연산자와 그 우선순위 관계는 직관적이지 않다. 이 규칙을 통해 개발자의 실수를 줄일 수 있다.
연산자의 우선순위를 명백히 하기 위해 괄호를 사용하는것은  개발자의 실수 가능성을 제거한다.
또한 코드의 유지보수 및 검토 시 원작자의 의도를 명확히 전달할 수 있다.
 </br></br>
괄호의 과도한 사용은 코드를 어지럽히고 가독성을 감소시킬 수 있다.
이 규칙은 괄호가 너무 적은 것과 괄호가 너무많아서 이해하기 힘든 코드 사이의 타협점을 찾는 것을 목표로 한다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_05</rule>
		<ruleTitle><![CDATA[수식의 값은 적절하지 않은 essential type으로 변환되지 않아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

명시적 형변환은 특정 상황에서 사용될 수 있다. 이에 대한 예는 다음과 같다.</br></br>

- 타입 변경을 통해 특정 산술 연산자가 수행되게 하기 위해</br>
- 의도적으로 값을 잘라내기 위해</br>
- 형 변환의 명확성을 높이기 위해</br></br>
명시적 형변환은 적합하지 않다:
</br></br>
- C99에서 _Bool로의 형변환 또는 할당은 항상 0 또는 1이다. 그러나 Essential 타입이 Boolean인 타입을 다른 타입으로 변환할 때는 그렇지 않다.</br>
- Enum essential 타입으로 변환하는 것은 해당 타입의 enumeration에 속하지 않는 값이 될 수 있다.</br>
- Essential 타입이 boolean인 객체를 다른 타입으로 변환하는 것은 의미가 없을 확률이 높다.</br>
- floating 타입과 character 타입간의 변환은 두 타입간
<br/><br/>
다음은 형변환이 허용되지 않는 경우를 표로 나타낸 결과이다.
<br/><br/>
<center>
<table border="1" cellpadding="3" cellspacing="0">
			<tbody>
				<tr align="center">
					<td>
						Essential type category</td>
					<td colspan="6" style="background:#E2DFB7">
						&nbsp;from</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						to</td>
					<td style="background:#E2DFB7">
						Boolean</td>
					<td style="background:#E2DFB7">
						character</td>
					<td style="background:#E2DFB7">
						enum</td>
					<td style="background:#E2DFB7">
						signed</td>
					<td style="background:#E2DFB7">
						unsigned</td>
					<td style="background:#E2DFB7">
						floating</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						Boolean</td>
					<td>
						&nbsp;</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						character</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						avoid</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						enum</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid*</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						signed</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						unsigned</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						floating</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
				</tr>
			</tbody>
		</table>
</center>
<br/>
<p>
<b>avoid*</b> 열거형 타입은 동일한 열겨형 타입으로 변환하는 것은 불필요하다.<br/>
추가로, void 타입을 다른 타입으로 변환하는 것에 대한 결과는 미정의된 특성이므로 허용되지 않는다. 이와 관련해서는 [MISRA_C_2012_01_03] 에서 언급한다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.3, Rule 10.8<br>
</p>

]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[기타]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_12_02</rule>
		<ruleTitle><![CDATA[shift 연산자의 우측 피연산자가 좌측 피연산자의 essential 타입의 범위 내의 정수여야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

우측 피연산자가 음수이거나 좌측 피연산자의 사이즈보다 크거나 같으면 정의되지 않은 행동이다.</br></br> 시프트 연산자의 좌측 피연산자가 16비트 integer이면, 이것이 0 - 15의 범위 내에서만 시프트 되는것을 보장하는 것은 매우 중요하다. essential type의 shift연산자에서의 제한과 설명에 대해서는 [Rule 8.10] 을 참고하라.</br></br>
 이 규칙을 보장하는 방법은 다양하다. 가장 단순한 방법은 우측 피연산자로 상수를 사용하는 것이다.( 값이 정적으로 확인될 수 있다. )</br></br> 피연산자가 unsigned integer 타입이면 음수가 아니므로 상한선만 확인하면 된다. 그렇지 않으면 상, 하 제한 모두 확인해야 한다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[사이즈]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_06</rule>
		<ruleTitle><![CDATA[복합 표현식의 값은 더 큰 essential 타입의 객체에 할당되지 않아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

C언어는 프로그래머에게 상당한 자유를 주고, 다른 산술 타입간의 할당이 자동적으로 처리되도록 한다. 그러나 이러한 묵시적 변환을 사용하는 것은 값, 부호, 정확도의 손실과 같은 의도치 않은 결과를 발생시킬 수 있다.

Misra의 essential 타입 모델에서 제안하는 더 강한 타입 제한을 사용하는 것은 이러한 문제 발생의 가능성을 줄여준다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.3, Rule 10.7, Section 8.10.3<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_12_03</rule>
		<ruleTitle><![CDATA[Comma 연산자 사용금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

comma 연산자의 사용은 일반적으로 코드의 가독성을 해치고, 콤마의 기능은 다른 방법으로 대체가능하다. 예를 들어 for 문의 선언부에 여러 변수를 콤마 연산자로 선언하는 경우가 있다. for 문의 증가식에 사용하는 변수를 제외하고는 for 문 이전으로 선언을 옮기면 콤마 연산자를 사용하지 않아도 된다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_03</rule>
		<ruleTitle><![CDATA[표현식의 값은 더 작은 essential 타입이나 다른 essential 타입 분류에 타입를 갖는 객체에 할당되지 않아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

C언어는 프로그래머에게 상당한 자유를 주고, 다른 산술 타입간의 할당이 자동적으로 처리되도록 한다. 그러나 이러한 묵시적 변환을 사용하는 것은 값, 부호, 정확도의 손실과 같은 의도치 않은 결과를 발생시킬 수 있다.

Misra의 essential 타입 모델에서 제안하는 더 강한 타입 제한을 사용하는 것은 이러한 문제 발생 가능성을 줄여준다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.4, Rule 10.5, Rule 10.6<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_12_04</rule>
		<ruleTitle><![CDATA[unsigned integer wrap-around를 발생시키는 상수 수식 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

unsigned integer 표현식은 overfolw에 엄격하지 않은 대신 wrap-around가 발생한다.
비록 런타임에서 modulo 연산을 사용하기 위해 쓰는 것과 같은 좋은 목적일지라도,
컴파일 타임에서는 의도한 것이 아닐 수 있다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[일반 산술 변환이 수행되는 연산자의 두 피연산자들은 필히 같은 essential 타입 분류에 속하는 타입이어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<b>이 규칙은 일반 산술 변환에 기술되어 있는 연산자들에 적용된다.</b><br/>
이 연산자들은 shift, 논리 &&, ++, 콤마 연산자를 제외한 이항 연산자들이다. 추가적으로 삼항 연산자의 둘째와 셋째 피연산자도 이 규칙에 의해 처리된다. 증감연산자는 이 규칙의 검사 대상이 아닌다.<br/><br/>

C언어는 프로그래머에게 상당한 자유를 주고 또한 다른 산술 타입간의 형 변환이 자동으로 수행되도록 한다. 그러나 이러한 묵시적 변환의 사용은 값, 부호, 정확도의 손실과 같은 의도치 않은 결과를 발생시킬 수 있다. 

MISRA essential 타입 모델에서 강제하는것과 같은 더 강한 타입 제약을 사용하는 것은 개발자가 정확히 의도한 답을 생산하도록 묵시적 변환을 제한한다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.3, Rule 10.7<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[기타]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_01</rule>
		<ruleTitle><![CDATA[부적절한 essential 타입의 피연산자를 사용하지 않아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>


아래 표는 연산자와 피연산자의 essential 타입에 대한 위배 내용을 나타낸다.<br/><br/>

<center>
<table align="center" border="1" cellpadding="6">
<tr align="center" >
<td rowspan="2">Operator</td><td rowspan="2">Operand</td><td colspan="6">Essential type category of arithmentic operand</td>
</tr>

<tr align="center" >
<td>Boolean</td><td>character</td><td>enum</td><td>signed</td><td>unsigned</td><td>floating</td>
</tr>

<tr align="center">
<td>[ ] </td><td>integer</td><td>3</td><td>4</td><td></td><td></td><td></td><td>1</td>
</tr>

<tr align="center">
<td>+ (unary)</td><td></td><td>3</td><td>4</td><td>5</td><td></td><td></td><td></td>
</tr>

<tr align="center">
<td>- (unary)</td><td></td><td>3</td><td>4</td><td>5</td><td></td><td>8</td><td></td>
</tr>

<tr align="center">
<td>+ -</td><td>either</td>
<td>3</td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>* /</td><td>either</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>%</td>
<td>either</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td></td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td>< > <= >=</td><td>either</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>== !=</td><td>either</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>! && ||</td><td>any</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>

<tr align="center">
<td><< >></td><td>left</td>
<td>3</td>
<td>4</td>
<td>5,6</td>
<td>6</td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td><< >></td><td>right</td>
<td>3</td>
<td>4</td>
<td>7</td>
<td>7</td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td>~ & | ^</td><td>any</td>
<td>3</td>
<td>4</td>
<td>5,6</td>
<td>6</td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td>?:</td><td>1st</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>

<tr align="center">
<td>?:</td><td>2nd and 3rd</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>


</table>
</center>
<br/>
<p>
<b>각 숫자의 위배 내용</b><br/><br/>
1. essential 타입이 floating인 표현을 []의 내부, %, <<, >>에 사용하는 것은 constraint 위반이다</br>
2. !, &&, ||, 그리고 ?: 연산자의 첫번 째 피연산자는 피연산자가 Boolean value로 처리되기 때문에 essential 타입이 Boolean인 표현만 사용되어야 한다.</br>
3. essential 타입이 Boolean인 표현은 산술 값으로 변환되는 연산자인 [], unary +, unary -, +, -, *, /, %, <, >, <=, >=, <<, >>, ~, &, |, ^에  사용되지 않아야 한다.</br>
4. 어떤 피연산자가 산술 값으로 변환된다면 essential 타입이 character 인 피연산자를 사용하면 안된다. 문자열 데이터를 저장하는 방법은 구현체마다 다르기 때문이다.</br>
5. enum 객체는 implementation-defined 정수 타입으로 저장되기 때문에 essential 타입이 enum인 피연산자는 산술 연산에 사용되지 않아야 한다. enum객체를 사용한 연산은 예상치 못한 타입의 결과값을 생성할 수 있다.</br>
6. Shift 및 bitwise 연산들은 essential 타입이 unsigned인 객체에 대해서만 수행되어야 한다. Essential 타입이 signed인 객체들을 대상으로 한 해당 동작은 구현체마다 다르다.</br>
7. Shift연산의 우측 피연산자는 essential 타입이 unsigned이어야만 음수 값으로 shifting을 시도함으로 발생하는 undefined behavior를 예방할 수 있다.</br>
8. 단항 minus연산의 피연산자로 essential 타입이 unsigned를 사용하지 말아야 한다. 각 구현체마다 int 크기가 다르기 때문에 해당 연산 결과의 부호 여부를 정확히 알 수 없기 때문이다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.2<br>
</p>

]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_02</rule>
		<ruleTitle><![CDATA[Essential 타입이 character인 표현식은 가감연산자에 부적합하게 사용되지 않아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

적합한 사용의 예는 다음과 같다.</br></br>
1. +연산자의 경우 피연산자 중 하나의 essential 타입이 character라면 다른 하나는 essential  타입이 signed거나 unsigned여야 한다. 이 연산 결과의 essential 타입은 character가 된다.</br></br>
2. -연산자의 경우 첫 번째 피연산자의 essential 타입이 character이라면 두 번째 연산자의 essential 타입이 signed거나 unsigned어야 한다. 만약 두 연산자의 essential 타입이 모두 character이라면 이 연산의 결과는 기본 타입(standard type; 보통 int)이고, 그렇지 않을 경우 character이다.</br></br>
essential 타입이 character인 수식은 데이터가 산술 값을 표현하지 않으므로 산술적으로 사용되지 않아야 한다.
위에 제시된 사용은 character 데이터의 수정을 허용한다.</br></br>
예를 들어:</br></br>
- essential 타입이 character인 두 피 연산자의 차는 '0'에서 '9'사이 값이 할당되어 있는 객체의 값을 변경할 수 있다.</br>
- essential 타입이 character인 피 연산자와 essential 타입이 unsigned인 피연산자의 합은 '0'에서 '9'사이 값이 할당되어 있는 객체의 값을 변경할 수 있다.</br>
- essential 타입이 character인 피연산자로부터 essential 타입이 unsigned인 피연산자를 빼는 연산은 소문자를 대문자로 변경할 수 있다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.1<br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_10</rule>
		<ruleTitle><![CDATA[표준 라이브러리 time, date 함수 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>"time.h"</b>에서 제공하는 기능은 사용해서는 안된다.<br/>또한, C99의 <b>wcsftime</b>를 사용해서는 안되며 매크로는 이 이름으로 확장되어서는 안된다.<br/><br/>시간과 날짜 함수는 그와 연관된 구체적이지 않은, 정의되지 않은, 실행 시 정의되는 행동을 포함한다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_11</rule>
		<ruleTitle><![CDATA[tgmath.h 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
<b>"tgmath.h"</b>의 함수 등을 사용하면 정의되지 않은 행동을 할 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_12</rule>
		<ruleTitle><![CDATA[fenv.h의 예외 처리 식별자 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
<b>feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, fetestexcept </b>는 사용하면 안되고, 매크로는 이 이름으로 확장되어서는 안된다.<br/>
Implementation-defined된 부동소수점 예외 매크로인 <b>FE_INEXACT, FE_DIVBYZERO, FE_UNDERFLOW, FE_OVERFLOW, FE_INVALID, FE_ALL_EXCEPT </b>는 사용하면 안된다.<br/><br/>
몇몇 상황에서 부동소수점 상태 flag의 값은 정해져있지 않고, 이에 접근하려는 시도는 정의되지 않은 행동을 한다.<br/><br/> <b>feraiseexcept 함수</b>에 의해 발생되는 예외의 순서가 정해져있지 않기 때문에 프로그램이 의도된 순서대로 정확히 동작하지 않을 수 있다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_09</rule>
		<ruleTitle><![CDATA[stdlib.h의 라이브러리 함수 bsearch, qsort 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>bsearch</b>와 <b>qsort</b>는 사용하지 않는 것이 좋고 매크로는 이들과 같은 이름으로 정의되면 안된다.<br/><br/> 요소들을 비교할 때 비교 함수가 일관되게 동작하지 않거나, 그 중 한 요소를 변경한다면 이는 정의되지 않은 행동이다. <br/> qsort의 구현은 재귀적으로 되어있을 것이고 스택 자원에 알 수 없는 요소를 배치한다. 임베디드 시스템에서는 일반적으로 스택의 크기가 작게 고정되어 있기 때문에 문제가 될 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_07</rule>
		<ruleTitle><![CDATA[stdlib.h의 atof, atoi, atol, atoll 함수 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>atof, atoi, atol</b>과 C99에서 추가된 <b>atoll</b>은 사용하지 않는 것이 좋고, 매크로는 이들과 같은 이름으로 정의되어서는 안된다. <br/><br/>
이 함수들은 문자열이 변환돨 수 없을 때 정의되지 않은 행동을 할 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_08</rule>
		<ruleTitle><![CDATA[stdlib.h의 라이브러리 함수인 abort, exit, getenv, system 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>abort, exit, getenv</b> 그리고 <b>system</b>함수는 사용하지 않는 것이 좋고 매크로는 이들과 같은 이름으로 정의되어서는 안된다.<br/><br/>
이 함수들은 이와 연관된 정의되지 않은, 실행 시 정의되는 행동을 포함한다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_05</rule>
		<ruleTitle><![CDATA[signal.h 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
Signal handling은 implementation-defined을 포함하고 정의되지 않은 행동을 한다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
스트림과 파일 입출력은 그와 연관된 구체적이지 않은, 정의되지 않은, 실행 시 정의되는 수많은 행위를 포함한다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 22.1, Rule 22.3, Rule 22.4, Rule 22.5, Rule 22.6<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[stdlib.h의 메모리 할당과 해제 함수 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>calloc, malloc, realloc</b>과 <b>free</b>는 사용하면 안되고, 매크로는 이들과 같은 이름으로 재정의하면 안된다. <br/><br/>
표준에서 제공하는 동적 메모리 할당과 해제를 사용하면 정의되지 않은 행동을 할 수 있다. 예를 들어:<br/><br/>
 - 동적으로 할당되지 않은 메모리의 해제<br/>
 - 해제된 메모리의 사용<br/>
 - 할당된 메모리에 값이 저장되기 전에 사용<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Dir 4.12, Rule 18.7, Rule 22.1, Rule 22.2<br/>
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_04</rule>
		<ruleTitle><![CDATA[setjmp.h 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>setjmp</b>와 <b>longjmp</b>를 사용하면 일반적인 함수호출 메카니즘이 생략될 수 있다. <br/>이들을 사용하면 정의되지 않고 지정되지 않은 행동을 할 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_01</rule>
		<ruleTitle><![CDATA[예약된 식별자 또는 예약된 매크로 이름을 #define 또는 #undef에 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
  예약된 식별자와 매크로 이름은 구현체에 의해 사용하기 위한 것이다. 예약된 매크로의 의미를 변경하거나 제거하는 것은 정의되지 않은 행동을 초래한다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 20.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_02</rule>
		<ruleTitle><![CDATA[예약된 지시자 또는 예약된 매크로 이름으로 선언 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
  프로그램은 예약된 식별자가 표준에 명시된 대로 행동하도록 설계되고, 그것들을 특별하게 처리한다. <br/>예약된 식별자가 재사용된다면, 프로그램은 정의되지 않은 행동을 한다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_14_01</rule>
		<ruleTitle><![CDATA[loop counter 의 essential 타입이 실수형이면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

실수형 loop counter 를 사용하면, 정수형으로 반올림할 때 오류가 발생하여, 실제로 반복하는 횟수가 개발자의 기대와  달라질 수 있다. 반복 과정에서 실수형의 소수점 이하을 반올림 할 수 없을 때 발생한다. <br/><br/>
어떤 코드에서 실수형 loop counter 가 올바른 동작을 하더라도, 다른 코드에서는 다른 숫자 값을 나타낼 수 도 있다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.2</br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

for 문의 구조는 다음과 같아야 한다:<br/><br/>
첫 번째 절</br>
&nbsp;&nbsp;&nbsp;&nbsp;- 비었거나</br>
&nbsp;&nbsp;&nbsp;&nbsp;- loop counter 에 값을 할당하거나</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- loop counter 를 정의하고 초기화 해야 함(C99)</br></br>
두 번째 절</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- 표현식은 side effect 가 없어야 함</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- loop counter 와 loop control flag 를 사용할 수 있음</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- for 문의 body 에서 변경하는 다른 객체는 사용하면 안됨</br></br>
세 번째 절</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- 표현식의 side effect 로 오직 loop counter 에만 값을 변경해야 함</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- loop body 에서 변하는 다른 객체는 사용하면 안됨</br></br>

for 문의 body 에서 호출하는 어떤 함수에도 마찬가지이다.</br>
loop control flag 는 for 의 두 번째 절에서 사용하는 Boolean 식에서 사용하는 객체이다.</br></br>
for 문은 다용도의 반복에 사용할 수 있다. 한정된 형태의 반복문을 사용하여 코드를 작성해야  검토하고 분석하기 쉽다. <br/><br/>
<b>예외사항</b><br/>
- for 문의 모든 절이 빌 수도 있다. <b>( ; ; )</b> 와 같은 무한 루프는 허용한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.1, Rule 14.3, Rule 14.4</br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_14_03</rule>
		<ruleTitle><![CDATA[결과가 항상 같은 제어식 사용 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

이 규칙은 다음에 적용된다:</br></br>
&nbsp;&nbsp;&nbsp;&nbsp;- if, while, for, do ... while 과 switch 문</br>
&nbsp;&nbsp;&nbsp;&nbsp;- ?: 연산자의 첫 번째 피연산자</br></br>

 제어식의 결과 값이 항상 같으면, 프로그램의 오류가 있을 수 있다. 컴파일러가 항상 결과가 같은 표현식 때문에 도달할 수 없는 코드를 지워버릴 수 있다. 이 때문에 실행될 수도 있는 방어 코드도 삭제 될 수 있다</br></br>
<b>예외사항</b></br>
&nbsp;&nbsp;&nbsp;&nbsp;	1. 무한 루프를 만들기 위한 표현식은 허용한다.</br>
&nbsp;&nbsp;&nbsp;&nbsp;	2. do ... while 문의 essentially Boolean 인 제어식이 0 으로 계산되면  허용한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 2.1, Rule 14.2</br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_14_04</rule>
		<ruleTitle><![CDATA[조건문이나 반복문의 제어식이 essentially Boolean type 인지 검사]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

조건문이나 반복문은 반드시 essentially Boolean type 이어야 한다.
for 문의 제어식은 없을 수도 있다. 이 규칙에서도 for 문에 제어식을 사용하지 않는 경우는 검출하지 않는다. 하지만 사용한다면 essentially Boolean type 이어야 한다.  

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.2, Rule 20.8</br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_03_02</rule>
		<ruleTitle><![CDATA[행 접합(Line-splicing)은 // 주석 내에서 사용하면 안 됨]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
Line-splicing은 newline 문자 뒤에 \ 문자가 붙어서 나올 때 발생한다.<br/>
만일 // 주석을 포함하는 소스 라인이 \ 문자로 끝난다면, 다음 라인도 주석의 일부로 포함된다. 이로 인해, 의도하지 않게 코드가 삭제될 수 있다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_C_2012_03_01</rule>
		<ruleTitle><![CDATA[문자열 /*와 //는 주석 안에서 사용하지 말아야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
주석 시작 문자열인 /*, //가 C 스타일 주석인 /* */ 안에서 사용되면, 주석 끝 문자열인 */를 사용하지 않고 지나칠 수 있다.<br/>
또한, 주석 시작 문자열이 // 주석 안에서 사용되면, 코드 영역이 주석처리 될 수 있다.<br/>
단, 문자열 "//"를 // 주석 안에서 사용하는 것은 허용한다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.4<br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<bug>
		<violationHash>989031760839006400718307357710633996931</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>136</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[stdlib.h의 메모리 할당과 해제 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[free는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>155305821295621568654034540724370457224</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>200</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>144726750083362190143145766959184797855</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>75354643381400106911722092289814822004</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[Assign 연산자의 결과는 사용하면 안됨]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>262649243122277541810962132915426226798</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1261162391194777186410732830712982376312</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[Assign 연산자의 결과는 사용하면 안됨]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>69917712527790701955447398135626330011</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>48001202351581014641231226592838894679</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>76987002098333312473762097282282119394</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>152488729291344558279033848363552884319</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>7</line>
		<rule>MISRA_C_2012_09_03</rule>
		<ruleTitle><![CDATA[배열은 일부분만 초기화 되면 안됨]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열 miro_map가 일부만 초기화되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>751877381032292265812361340818290733736</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>100038661684108992055553388237239725499</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>71149248457468399631580452977108023728</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>78</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 prev 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>55357151937200524137471960347597709486</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>142</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 +는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1190674745541002771415539231029605834637</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>171</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>19070704650938563729692360013245538456</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>54</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>145809272643752286216250964789653481765</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>89</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 save가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>108666001181973411481348438775053492600</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>44</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>168628169688014213954243559786672972625</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>642719654210836527316724635553328439974</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>42027721248371447788627791828736213854</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>1</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[stdio.h는 include가 금지된 파일임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>108080164428463774839636883471280948092</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>73620035301302782606337010817689204294</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>139</line>
		<rule>MISRA_C_2012_03_01</rule>
		<ruleTitle><![CDATA[문자열 /*와 //는 주석 안에서 사용하지 말아야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[주석 안에서 주석 시작 문자열인 "//"가 사용됨]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>88797419779129549984793129456819281467</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>131</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 prev 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>252584477834515876416402112256448273337</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>110</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 check 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>181848303809955449169920858814173488721</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>143586349528854059862459474187792220066</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>136</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1571492158631202250411209574031982609149</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>130</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>92772112473748825013041440514007845589</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>25</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 prev 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>9696768542615982058749200467523288176</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>234</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>141294633189075278323510189706997988334</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>48</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 tail가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1668215284383188115110549659739157368446</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>178</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>55186918177548431516219883924876701330</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>127452828290206097710956684504030920335</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>50</line>
		<rule>MISRA_C_2012_15_05</rule>
		<ruleTitle><![CDATA[함수는 마지막에 하나의 return만 가지는지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 miro_check 는 3 개의 exit point 를 가짐 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>28662996060327484626878279730921123382</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>78</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>163284681766353918976548976336847695935</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>50</line>
		<rule>MISRA_C_2012_08_07</rule>
		<ruleTitle><![CDATA[함수나 객체가 하나의 번역단위에서 참조된다면 외부참조(external linkage)로 정의되면 안됨]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 miro_check는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1590646930338735948416567599639181221586</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 after가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1432837913888395399612948418827883198239</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>96</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 prev 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>705429734066429909912174559066177043474</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>49</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1446807581177185688117698360989506702035</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>3</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[함수는 이름 있는 파라미터로 구성된 프로토타입 형태여야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 Q_make의 파라미터가 없지만 명시적인 void 타입 파라미터를 선언하지 않았음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>3040043782034673693198691864256166862</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>35</line>
		<rule>MISRA_C_2012_08_04</rule>
		<ruleTitle><![CDATA[객체나 함수의 정의 또는 호출 이전에 호환가능한 선언이 존재해야함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 miro_way_completionS의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1401611761724287586216249388187139988498</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>48</line>
		<rule>MISRA_C_2012_15_05</rule>
		<ruleTitle><![CDATA[함수는 마지막에 하나의 return만 가지는지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 map_re_find 는 2 개의 exit point 를 가짐 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>245834442670822069511329153980935781459</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>157</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1064451714421883040017256917288759702332</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 &&는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>508964934546359175612920132911991617912</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>131</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[매크로 NULL은 정수 null 포인터 상수만으로 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[null 포인터 상수가 매크로 NULL 또는 (void*)0 으로 사용되지 않음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>275694640414686280010344508862284521970</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1202476342908339683417835732745208525203</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>48</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 매개변수 tail 를 변경하였음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>60198007877872369342319237227253308736</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>30</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[stdlib.h의 메모리 할당과 해제 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[malloc는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>74480350889082828061533120095267236561</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>94</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>142281154328529248426492272116361441329</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>129</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1237002612267392731016784305321592388618</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>132</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>97172856632655061666289466719385259631</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>57</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>99352062370922594917104259221385949027</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>402141315205722814516908695493452761095</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>210897340036163809111090476516172837851</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>103807489620408721942510165482908784357</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>377998062844629191416686426144967074530</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>144266507859617288605062129407109568286</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 tail가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>173345526930324987228988923887501342307</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>25676588903911462437721970412322693923</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>142</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>113144675389166505881591135745826540415</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>47</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 node가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>441206738674209389812727215859300114320</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>171</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1666750063390078535123175405713928458</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>128</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>719964075494420486214927790467068646366</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>97</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>101193993506019741661379243257401418188</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>185</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>104391938132174816147376315946886732044</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>218</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>170581597695887422124159147020061727813</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>127</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 매개변수 head 를 변경하였음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>48389595804329112217060248111901910702</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>72</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[일반 산술 변환이 수행되는 연산자의 두 피연산자들은 필히 같은 essential 타입 분류에 속하는 타입이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[일반 산술변환의 두 피연산자가 다른 essential type임 ( char / signed )]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1433747517244062338414247833885958043231</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>78</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[매크로 NULL은 정수 null 포인터 상수만으로 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[null 포인터 상수가 매크로 NULL 또는 (void*)0 으로 사용되지 않음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1816520558926239067812542687434191356759</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>3</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[함수는 이름 있는 파라미터로 구성된 프로토타입 형태여야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 Q_make의 파라미터가 없지만 명시적인 void 타입 파라미터를 선언하지 않았음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1191986556702397262515842980545130762541</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1654800708136514667813685594772487900154</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>213</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1369992413443229698015557996945339830066</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>121</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14742241633171811637986651282578392791</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>131</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1582421679492730783318366961047257083420</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 매개변수 x 를 변경하였음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>374521848069385176714846061876151276336</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 매개변수 after 를 변경하였음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1580208659740405544817657061767084418911</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>91</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>183590411368386946782115028380329909992</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>141</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>227181492250775033317471700116310988448</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>142</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>125506485914579139139564345054920780260</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>90</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[일반 산술 변환이 수행되는 연산자의 두 피연산자들은 필히 같은 essential 타입 분류에 속하는 타입이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[일반 산술변환의 두 피연산자가 다른 essential type임 ( char / signed )]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>10656319764668465821939944395428839022</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>50</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 매개변수 addr_check 를 변경하였음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1727588961201365699716475199270580640540</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>7</line>
		<rule>MISRA_C_2012_21_08</rule>
		<ruleTitle><![CDATA[stdlib.h의 라이브러리 함수인 abort, exit, getenv, system 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[system는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>100355834863859655445911884008539802688</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>160408187612044273762658277520739345662</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>110</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[일반 산술 변환이 수행되는 연산자의 두 피연산자들은 필히 같은 essential 타입 분류에 속하는 타입이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[일반 산술변환의 두 피연산자가 다른 essential type임 ( char / signed )]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>41430217565471155531020534538361004999</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>74</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>974673602966398001718309270950897070977</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>67</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 node가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>3347272610016852278228234596864878440</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>8</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>76594916667352977114385094220119241924</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>133</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1524477798011165591817299948616047298557</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>39</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[매크로 NULL은 정수 null 포인터 상수만으로 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[null 포인터 상수가 매크로 NULL 또는 (void*)0 으로 사용되지 않음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>745286801002685933014903462727358640480</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[Assign 연산자의 결과는 사용하면 안됨]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>440555405339447035912221986313988451149</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>43</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>125597968387949236126669362549364314336</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>65</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 head가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>48175055278820644143890860025789706762</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>3344616267705635362154517020135295987</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>68</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[일반 산술 변환이 수행되는 연산자의 두 피연산자들은 필히 같은 essential 타입 분류에 속하는 타입이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[일반 산술변환의 두 피연산자가 다른 essential type임 ( char / signed )]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>286956281007060656214867280826990948771</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>81</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>195377726973966108018017765682186449053</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>93</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 prev 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1568547216760656542312255335913083799822</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>91</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1242301458654992731910785059752821922308</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>27</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1261738049947828172913135000447417094082</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>96</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[매크로 NULL은 정수 null 포인터 상수만으로 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[null 포인터 상수가 매크로 NULL 또는 (void*)0 으로 사용되지 않음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>21601510054632964637823867875023212662</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>63</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>119388052592559561037608253436419800223</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>17</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>172621826017714408081237247273288243277</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>4</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[함수는 이름 있는 파라미터로 구성된 프로토타입 형태여야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 main의 파라미터가 없지만 명시적인 void 타입 파라미터를 선언하지 않았음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>11405756922726407901662687789104027197</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>15</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>109937876666725769878970521402039170889</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>7</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 system의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1724364035698015534716215932671156118193</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>130</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>840602838951498927411443412621824060843</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[Assign 연산자의 결과는 사용하면 안됨]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1160580549310018487217772065571581417471</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_C_2012_08_03</rule>
		<ruleTitle><![CDATA[동일한 객체 또는 함수의 모든 선언은 같은 이름과 타입 한정자를 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수의 선언에 사용된 파라미터의 이름 move과 정의에 사용된 파라미터의 이름 moving이 같지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1708573191990533203210407413932590647539</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1560887621102654817916662390781437168974</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>48</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 num 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>149511869056505460553438650308620583721</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>164</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>335314025767324589011688524766491346029</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>70</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>131806083794294966796099276229741187313</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>135</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1556590440612422957414200958714549915990</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>134</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>74359410520524578515674661466083253488</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>193</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1376630547019426516113304685953994423036</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>15</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>15879890303191768171694371435060695892</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>140</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1521461403639992804677249652354292209</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>74</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17461820826656469123868973904629430562</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>61387442190097431719877257322078977960</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1253258114815192498813649840894619084562</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 &&는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>634297109251432390315875473937245216297</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>8</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[stdlib.h의 메모리 할당과 해제 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[malloc는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>135774795289481742549527507395217004604</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 &&는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>72280292772940219199134807359381105110</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>138</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1842570057762379226311134513019828834800</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>65</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>19476885992737609312944820238728989014</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 &&는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>126765287487026580222120303462012337514</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>208</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>115926189583861497473512140102081400470</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>91</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>565257011500874281113793468166828522471</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>110</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 prev 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>139426891858821204387351608395070646125</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_08_07</rule>
		<ruleTitle><![CDATA[함수나 객체가 하나의 번역단위에서 참조된다면 외부참조(external linkage)로 정의되면 안됨]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 miro_return는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>29563008486969085084244711587679722969</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>50</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[일반 산술 변환이 수행되는 연산자의 두 피연산자들은 필히 같은 essential 타입 분류에 속하는 타입이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[일반 산술변환의 두 피연산자가 다른 essential type임 ( char / signed )]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>170866590949675934874637697041968947086</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 next 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>6347742158903414504945851845448431456</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>23</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 node가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>760075582316924549213268351191537667819</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>73</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>925360084151939871315998796876334935386</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 &&는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>115613571025186971576746528157937244507</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>106</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[일반 산술 변환이 수행되는 연산자의 두 피연산자들은 필히 같은 essential 타입 분류에 속하는 타입이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[일반 산술변환의 두 피연산자가 다른 essential type임 ( char / signed )]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>63763636910567494289921612130333399341</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1400548028122848759116716231390978192930</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>802344962358271330910031417666683287996</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>101</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>49448318666597782209089917298612730245</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>134</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[stdlib.h의 메모리 할당과 해제 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[free는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>555796107742847535118189652129502728516</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1145337054178582531517915229934167617688</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>52</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>156583759659560951988121424234194681992</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>87</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>18297488360819838810256891561620549709</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_08_04</rule>
		<ruleTitle><![CDATA[객체나 함수의 정의 또는 호출 이전에 호환가능한 선언이 존재해야함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 miro_return의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1459802518877532417110479676333496405105</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>200</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>6330671179912470826447018744698102939</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>123</line>
		<rule>MISRA_C_2012_15_04</rule>
		<ruleTitle><![CDATA[반복문에는 하나의 break 나 goto 문만 있는지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[반복문에 jump 문이 최대 하나만 사용되어야 하는데 9 번 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>116379814273797751818258694515195530578</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>134381426968978940968753832041521838052</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>35</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 tail가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>35787912088037422305218578708430121381</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>45</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 tail가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>18407029203583406360353647880595937119</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>823505130341483547611290459248267157522</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>61</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>618532768233204707014204167690813553326</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 &&는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>132195981916033543463989411247838761596</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>157</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>242016688570096007414835110870121673429</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>140</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>400142593004901905115178661171496324205</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 &&는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1378180830329378703111528090951702295049</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>88</line>
		<rule>MISRA_C_2012_21_02</rule>
		<ruleTitle><![CDATA[예약된 지시자 또는 예약된 매크로 이름으로 선언 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[remove는 선언 및 정의가 금지된 변수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>362053605481186128217648193681101751276</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>63</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 system의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>95877004576714164061575215398577073306</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>39</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 prev 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>182632652834943014715302050643495773500</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>137264684712837844271783080504861143420</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>128</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1510235331973773560715840093116153681928</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>7</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[stdlib.h의 메모리 할당과 해제 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[malloc는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1835517797108282408110712910006541269143</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>47</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>87997910460386883483672458026459777072</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 &&는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>663062459034121158610224453031776417257</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>137</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1056261040084253906113725719416811889339</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>126</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>64327240298343503399199554006531794320</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 매개변수 y 를 변경하였음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>23756714061454065955771843995577476949</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[Assign 연산자의 결과는 사용하면 안됨]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>111305604343181679887158078179035549162</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>52</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>726784426027806741812028106757672870669</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>132</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>828181231825088176212410812041632704111</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>178</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1059087154350748956411986855909012335505</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>36639970956967467532920942703174540469</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 매개변수 now 를 변경하였음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>115638872346293616628800800681121127344</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>185</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1813643446002810297717372603046817180934</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>114</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[stdlib.h의 메모리 할당과 해제 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[free는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>324519137752215803210264498940421153764</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[Assign 연산자의 결과는 사용하면 안됨]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>131128648904915852134479322776263647634</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>36</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[함수는 이름 있는 파라미터로 구성된 프로토타입 형태여야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 Q_make의 파라미터가 없지만 명시적인 void 타입 파라미터를 선언하지 않았음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1768961587235980278712270038081017612444</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>463400679824403741111747426866894435152</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>193</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>234937108002088962917172355029526475814</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>136</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>97915607428658753426923831659099116120</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>86</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 head가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>154827097599999270794185316437811800552</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>134</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>103637112651758796616373023921024287934</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>21</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 tail가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>105576540473560397204581905480058695450</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 <=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>34699396595192948938694407858822401812</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>139</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>11608635258763659898456613200077093336</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>63</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>117518632730048738823372571387032164097</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>208</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1030959622594551225514897789088733352875</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>80</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>504182494885488465947858794011813151</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>126</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 ==는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>62987850263956061685270928336768613687</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>74</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>805405444400305819112406755122361866731</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>88</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 remove가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1161335662750420428616359249008212512930</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>138</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>7608849820353278806207911978676040649</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>213</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>74683491047494208458333606363745300538</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>103</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[stdlib.h의 메모리 할당과 해제 함수 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[free는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>106202559223263237399534975030711094425</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<line>11</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>214504569659516882913887882974359888239</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>41</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1787399044478592738014790303615636328404</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>12</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>708671143403296927517069795333369627953</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>127</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>975877837966242031411654871819467363819</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>52</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>638539071898556142310956049943692643047</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>93</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>6568310761062603303769450582633433378</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>93</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[매크로 NULL은 정수 null 포인터 상수만으로 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[null 포인터 상수가 매크로 NULL 또는 (void*)0 으로 사용되지 않음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>108827086862245353475075562550495576376</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>63</line>
		<rule>MISRA_C_2012_21_08</rule>
		<ruleTitle><![CDATA[stdlib.h의 라이브러리 함수인 abort, exit, getenv, system 사용 금지]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[system는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>104588327857849357746637263449833047860</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>25</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[매크로 NULL은 정수 null 포인터 상수만으로 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[null 포인터 상수가 매크로 NULL 또는 (void*)0 으로 사용되지 않음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>933304895027602846316895335367314004580</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>69</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[for문의 num 제어변수가 initialization 식에서 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>833806609631418438710338044196364323527</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1690183399194859051111140754506640447702</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>4</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[함수는 이름 있는 파라미터로 구성된 프로토타입 형태여야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 main의 파라미터가 없지만 명시적인 void 타입 파라미터를 선언하지 않았음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>98203153842794583527884184447243620609</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[Assign 연산자의 결과는 사용하면 안됨]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>223176702209376835315279834023446296580</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>35</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17010128632843275776196096464244871230</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>70</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>74971271760550431459413309994029256754</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>142</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 -는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>128452924539248973613190840047614720142</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>164</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>69981653924818952998298545887068692376</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[연산자 >=는 괄호가 필요함]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>392576920256906812410533014061279092102</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>859683322524972968512778459747514560331</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[Assign 연산자의 결과는 사용하면 안됨]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>115251074001671083871638702610151350324</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>37</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 node가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>437781167624757409511477481944215493190</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>47</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>459213144395697637118201709922341795246</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>24</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 매개변수 tail 를 변경하였음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>88857729508215857996403594381872564624</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>54</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 변수 또는 인자 node가 수정되지 않았지만, base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>23977135733974845611936016966267628046</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>97</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>6952012920379858338987084346415579642</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>123</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>148346944568834164446702715035630849692</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>15</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터 타입의 수식에 연산자 +가 사용되었음]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>2.0</ndf>
		<necl>7.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>3.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>10.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>4.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<cc>29.0</cc>
		<ncl>11.0</ncl>
		<nfp>4.0</nfp>
		<ncf>2.0</ncf>
		<ndf>7.0</ndf>
		<necl>91.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>5.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>3.0</ncf>
		<ndf>1.0</ndf>
		<necl>10.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>0.0</nfp>
		<ncf>3.0</ncf>
		<ndf>1.0</ndf>
		<necl>9.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<cc>5.0</cc>
		<ncl>3.0</ncl>
		<nfp>2.0</nfp>
		<ncf>2.0</ncf>
		<ndf>1.0</ndf>
		<necl>12.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<cc>5.0</cc>
		<ncl>2.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>9.0</ndf>
		<necl>29.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<cc>4.0</cc>
		<ncl>3.0</ncl>
		<nfp>4.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>14.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>NaN</ncf>
		<ndf>0.0</ndf>
		<necl>3.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>0.0</nfp>
		<ncf>NaN</ncf>
		<ndf>12.0</ndf>
		<necl>28.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>5.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>1.0</nfp>
		<ncf>4.0</ncf>
		<ndf>4.0</ndf>
		<necl>9.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<cc>8.0</cc>
		<ncl>4.0</ncl>
		<nfp>1.0</nfp>
		<ncf>2.0</ncf>
		<ndf>2.0</ndf>
		<necl>22.0</necl>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>NaN</ncf>
		<ndf>2.0</ndf>
		<necl>7.0</necl>
	</metric>
</ci.CodeInspectorResult>
