<?xml version="1.0" encoding="UTF-8"?>
<ci.CodeInspectorResult>
	<summary>
		<prjName></prjName>
		<toolName>CodeScroll Code Inspector</toolName>
		<toolVersion>3.7.8.201901031810</toolVersion>
		<numberOfCodeViolation>242</numberOfCodeViolation>
	</summary>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<crc32>9743c5d2</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<crc32>8fca5527</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<crc32>4b9511cd</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<crc32>d46300a5</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<source>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<crc32>ca4f4382</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_19_01</rule>
		<ruleTitle><![CDATA[Unsigned integer 타입 상수 식의 평가가 wrap-around를 일으키면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Unsigned integer 표현식은 overflow가 생기지 않기 때문에, (대신에 모듈 방식으로 wrap around가 발생한다.) 오버플로우를 발생시키는 어떤 unsigned integer 상수 식도 컴파일러가 발견할 수 없다. 따라서 unsigned integer 상수 식에서 일어나는 wrapping around의 경우 프로그래밍 에러를 나타내는 경향이 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_18_07_01</rule>
		<ruleTitle><![CDATA[라이브러리 <csignal>의 신호 핸들링 기능은 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 신호 핸들링은 implementation-defined이며, 정의되지 않은 행동을 포함한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_27_00_01</rule>
		<ruleTitle><![CDATA[스트림 입력/출력 라이브러리 <cstdio>는 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙은 파일과 입력 출력 함수들 fgetpos, fopen, ftell, gets, perror, remove, rename 등을 포함한다. 스트림과 파일 입력 출력은 그와 관련된 수많은 unspecified, undefined, implementation-defined behavior를 가져온다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_09_03_03</rule>
		<ruleTitle><![CDATA[static 또는 const로 선언할 수 있는 member 함수들은 static 또는 const로 선언해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 static으로 선언할 수 있는 member 함수는 해당 함수를 static으로 한정하여 non-static data member에 접근하는 것을 막고 const로 선언할 수 있는 member 함수는 const로 선언하여 데이터의 값이 의도치 않게 변경되는 것을 막아야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_09_03_02</rule>
		<ruleTitle><![CDATA[member 함수에서 클래스 데이터의 const가 아닌 핸들 반환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 member 함수들과 같은 클래스 인터페이스를 구현함으로써 객체의 상태가 어떻게 변경되는지를 명확히 조절할 수 있게 된다. 그러나 클래스 데이터에 대한 핸들을 반환하는 것은 해당 객체의 상태를 클래스 인터페이스를 통하지 않고도 변경할 수 있기 때문에 바람직하지 않다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_09_03_01</rule>
		<ruleTitle><![CDATA[const member 함수에서 클래스 데이터를 가리키는 non-const pointer나 reference 반환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 기본적으로 const member 함수는 해당 함수의 호출로 인해 객체의 상태가 변경되지 않다는 것을 보장한다. 그러나 const member 함수에서 클래스 데이터를 가리키는 non-const pointer나 reference가 반환된다면 이렇게 얻어진 클래스 내부의 상태를 프로그램의 다른 부분에서 언제든 수정할 수 있기 때문에 안전하지 않다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_01_00_01</rule>
		<ruleTitle><![CDATA[사용하는 코드는  C++ 표준을 준수해야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
MISRA C++ 은 ISO_IEC 14882_2003[1]를 기반으로 한다. 사용하는 C++ 컴파일러가 표준과 다르다면 ISO_IEC 14882_2003[1] 를 통해 다른요소들을 확인하여야 한다.
<br/>
<br/>
<b>참고문헌</b><br/>
[1] ISO/IEC 14882:2003: The C++ Standard Incorporating Technical Corrigendum 1, International Organization For Standardization, 2003
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_01_00_02</rule>
		<ruleTitle><![CDATA[다중 컴파일러 사용 제한 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 다중 컴파일러는 공통적으로 정의된 인터페이스를 가질 때만 사용한다. 다중 컴파일러는 혼합된 언어, 다른 컴파일러, 같은 컴파일러의 다른 버전이나 같은 컴파일러의 다른 형상을 의미한다. 다중 컴파일러는 C++ 언어의 특성을 이해하고 있어야 한다. 이 규칙은 extern 'C' 의 사용을 포함한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_01_00_03</rule>
		<ruleTitle><![CDATA[컴파일러에서 정수 나눗셈을 문서화해야 함  ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  ISO를 준수하는 컴파일러는 부호가 서로 다른 signed integer의 나눗셈에서 둘 중 하나의 동작을 할 수 있다. 첫 번째로, 음수 나머지(-5/3 = -1 나머지 -2)로 계산할 수도 있고 양수 나머지(-5/3 = -2 나머지 1)로 계산할 수도 있다. 컴파일러에 의해 실행된 결과를 결정하고 문서화 하는 것이 개발자를 위해 중요하다. 이 규칙은 나눗셈의 정의와 마찬가지로 나머지 계산의 정의도 포함하고 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_09_05_01</rule>
		<ruleTitle><![CDATA[union을 사용하지 않아야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 union은 경우에 따라 적절치 못한 값으로 해석될 수 있고 이는 큰 문제를 야기할 수 있다. 따라서 union을 사용하지 않아야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_04_03</rule>
		<ruleTitle><![CDATA[어셈블리 코드는 캡슐화되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 어셈블리 코드를 캡슐화하면 프로그램의 이식성을 증대시킬 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_04_02</rule>
		<ruleTitle><![CDATA[어셈블러 명령어는 asm 선언을 통해서만 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 언어 표준에 있는 asm 선언을 통하여 어셈블러 명령어를 사용해야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_04_01</rule>
		<ruleTitle><![CDATA[모든 어셈블러 사용은 문서화되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/> 어셈블리어 코드는 구현체마다 동작이 다르므로 사용하지 않아야 한다. ]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_04_01</rule>
		<ruleTitle><![CDATA[함수의 선언이 예외 기술절(exception-specification)을 갖는 경우에, 동일한 함수 선언은 동일한 예외 기술절을 가져야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 소스코드간의 다른 예외 기술절을 갖는 함수는 함수 호출 시 어떠한 동작이 발생될지 예측할 수 없다(undefined behavior). 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_17_01</rule>
		<ruleTitle><![CDATA[이진 연산과 그 할당 연산은 의미가 동일해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 연산자들이 오버로드 되었을 때, 해당 연산자의 결과는 개발자의 예상대로 나와야 한다. 예를 들어, + 연산자를 사용해서 얻은 값과 += 연산자를 사용해서 얻은 값은 같아야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_01_02</rule>
		<ruleTitle><![CDATA[블럭단위에 함수 선언 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
블럭단위에 함수를 선언하는 것이 필요하지 않으며, 해당 함수의 선언이 필요하다면 함수 밖에 선언하면 된다. 
<br/><br/>
함수안에 선언을 넣게 되면, 아래 예제 처럼 함수 선언과 객체의 정의와 헷갈리는 상황이 발생할 수 있다.
<br/><br/>
<center>
<table>
<tr><td>
<pre>
class A{ };
&nbsp;&nbsp;&nbsp;&nbsp;void b1(){
&nbsp;&nbsp;&nbsp;&nbsp;void f1 ();
&nbsp;&nbsp;&nbsp;&nbsp;A a ();       // function declaration? or object definition?
}
</pre>
</tr></td>
</table>
</center>
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_01_01</rule>
		<ruleTitle><![CDATA[헤더 파일에 함수나 객체 정의 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
헤더 파일 다양한 선언들만 사용해야 하고 객체의 정의나 함수의 정의를 포함하면 안 된다. 
<br/>
C/C++ 은 ODR(one definition rule)에 따라 동일한 함수나 객체는 전체 프로그램에서 유일하게 존재해야 하며, 헤더파일에 이러한 객체 정의나 함수의 정의를 포함하게 되면 미숙한 개발자가 #include 로 해당 헤더를 포함하여 문제를 발생시킬 위험이 있다. 따라서 사전에 이런 위험을 관리하기 위해서는 헤더에는 객체나 함수의 정의를 포함시키지 않는 것이 좋다. 
<br/>
<br/>
성능을 위한 inline 과 static 정의는 이 규칙에서 제외된다.
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_01_03</rule>
		<ruleTitle><![CDATA[배열 크기가 명시적이어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 배열의 크기를 명시적으로 정해주는 것이 안전하다. 명시적으로 배열의 크기를 표시해 주면 컴파일러가 배열의 크기를 확인하고 올바르지 않으면 경고해 줄 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_07_02</rule>
		<ruleTitle><![CDATA[어떠한 템플릿 특수화(specialization)가 일어난 후에도 ill-formed 프로그램 작성 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 묵시적 템플릿 특수화는 템플릿의 모든 멤버를 instantiate 하지 않는다. 반면에 주어진 템플릿-인자(template argument)의 결과가 사용되는지 명확하지 않을 때에도 멤버에 대한 instantiation 은 ill-formed 를 일으킬 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_07_01</rule>
		<ruleTitle><![CDATA[모든 템플릿과 관련된 선언들은 최소 한번은 instantiation 이 되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 호출되지 않은 함수와 마찬가지로, un-instantiated 클래스나 함수들은 잠재적으로 필요 없는 코드들이다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_07_03</rule>
		<ruleTitle><![CDATA[모든 부분 특수화와 명시적 특수화는 템플릿 선언과 같은 파일에 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 컴파일러에 의해 생성된 묵시적 instantiation 이 프로그램의 다른 부분에서 부분적 또는 명시적으로 특수화되면 undefined behavior 이다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_06_01</rule>
		<ruleTitle><![CDATA[#pragma 지시자의 모든 사용은 기록되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #pragma 지시자는 implementation-defined이기 때문에, 모든 사용이 정확함을 증명하는 것이 중요하다. 이 규칙은 사용된 pragma 지시자의 리스트를 만들고 문서화 하기를 요구한다. 이 리스트는 pragma의 동작과 그 영향을 이해할 수 있도록 설명해주는 정도면 충분하다. pragma는 가능한 한 최소한만 사용하며, 지역화, 캡슐화가 되어있어야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[기타]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_06</rule>
		<ruleTitle><![CDATA[함수 포인터에서 다른 포인터 타입으로(다른 함수 포인터 포함) 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 함수 포인터에서 함수가 아닌 포인터 타입으로의 변환은 undefined behavior를 발생시킨다. Undefined behaviour는 함수 호출이 함수 포인터 변환의 결과인 포인터를 사용해서 이루어질 때 또한 발생할 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_07</rule>
		<ruleTitle><![CDATA[포인터 타입 객체는 관련 없는 포인터 타입으로 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 포인터 타입 객체는 관련 없는 포인터 타입으로 직, 간접적 변환하면 안 된다. 포인터에서 관련 없는 타입으로의 변환 결과는 정의되어 있지 않다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_04</rule>
		<ruleTitle><![CDATA[C-스타일 변환과 함수형 표기(functional notation) 변환은 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C-스타일 변환과, 변환 생성자를 호출하지 않는 함수형 표기 변환은 관련 없는 타입 간의 변환을 가능하게 하기 때문에 사용하면 안 된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
void로의 C-스타일 변환은 non-void 함수 호출의 반환 값이 무시된다는 것을 확인하기 위해 쓰일 수 있다. 그리고 explicit 생성자 호출 또한 허용한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.2.3, §5.4]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_05</rule>
		<ruleTitle><![CDATA[변환 하면서 포인터나 참조형의 const 또는 volatile이 누락되면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 타입에서 const 또는 volatile이 누락되면 개발자가 의도하지 않은 undefined behaviour가 발생할 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_02</rule>
		<ruleTitle><![CDATA[Virtual 상위(base) 클래스를 가리키는 포인터는 dynamic_cast를 이용해서 하위(derived) 클래스를 가리키는 포인터로의 변환해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Virtual 상위 클래스에서 하위 클래스로의 변환에서, dynamic_cast 이외의 방법은 정의하지 않은 동작을 할 가능성이 있다. dynamic_cast의 동작은 정의되어 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_03</rule>
		<ruleTitle><![CDATA[상위(base) 클래스를 하위(derived) 클래스로 변환하는 것은 다형(polymorphic) 타입 간에 이루어져서는 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 하위 변환(downcast)은 자신이 하위 클래스 타입으로 변환될 때 이루어진다. 다형성은 계층(hierarchy)의 인터페이스와 구현 사이에 강한 추상화를 가능하게 한다. 명시적인 변환은 이러한 추상화 계층을 무시하기 때문에 높은 수준의 결합성(coupling)과 종속성(dependency)을 갖는다. 즉, 추상화를 해치기 때문에 좋은 코드가 아니다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_04_01</rule>
		<ruleTitle><![CDATA[하나의 함수에서만 사용되는 변수는 함수 scope에 정의해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 최소의 block scope에 값을 선언하면 그 값의 가시성을 줄여서 의도하지 않은 사용을 줄일 수 있다. 전역 객체는 둘 이상의 함수에서 사용해야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙에서는 피연산자가 적절한 괄호로 싸여있기를 원한다. 괄호를 사용하는 것은 코드 가독성에도 좋고, 코드를 작성한 개발자의 의도를 알아차리는 데에도 중요한 역할을 한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
표현식이 logical &&, 또는 logical ||만으로 이루어져있다면 추가적인 괄호는 필요하지 않다. (후위 표현식(postfix-expression): 일차식(primary-expression) 또는 일차식에 후위 연산자가 붙은 표현식) ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_12_08_01</rule>
		<ruleTitle><![CDATA[복사 생성자는 기본 클래스들과 그 클래스들의 non-static 멤버들만 초기화해야 한다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 복사 생성자가 어떤 객체의 사본을 만드는 것 외에 다른 동작을 하더라도 컴파일러가 복사 생성자의 호출이 필요 없다고 판단될 때 컴파일러는 해당 호출을 무시할 수 있다.  이를 copy elision이라 한다. 이러한 값의 변경들이 애매하기 때문에 복사 생성자는 필히 프로그램의 상태를 변경하지 않도록 해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_11</rule>
		<ruleTitle><![CDATA[comma, &&, || 연산자는 연산자 오버로딩 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 comma와 논리 결합 연산자의 오버로드된 버전은 그 시퀀스 포인트와 문법의 순서가 기존 버전과 다를 수 있다. 그리고 사용하는 시점에서 이 연산자가 오버로드 되었는지 명확하지 않은 경우가 있다. 따라서 개발자는 어떤 의미로 쓰였는지 혼동할 수 있으므로 오버로딩하지 않는 것이 안전하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.14, §5.15, §5.18]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 배열 타입 변수가 포인터로 망가지면, 그 범위 값을 잃는다. 만약, 디자인이 다른 길이의 배열을 요구한다면, 클래스는 배열 객체를 감싸고, 차원 수가 유지되도록 해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_10</rule>
		<ruleTitle><![CDATA[표현식(expression)에서 ++과 -- 연산자는 다른 연산자와 혼용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 ++, -- 연산자가 다른 산술 연산자와 혼용되는 것은 추천하지 않는다. 왜냐하면 코드의 가독성을 해칠 수 있으며, 잠재적인 undefined behaviour를 가져서, 연산자를 포함한 문장(statement)에 추가적인 side effect를 가져올 수 있다. 이러한 연산자는 다른 산술 연산자로부터 독립적으로 쓰이는 것이 안전하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.2.6, §5.3.2]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_08</rule>
		<ruleTitle><![CDATA[정수 타입 또는 void 타입을 가리키는 포인터를 포인터 타입 객체로 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 일반적으로, 정수 또는 void 타입을 가리키는 포인터를 객체로 변환하는 것은 unspecified behavior를 발생시킨다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_02_09</rule>
		<ruleTitle><![CDATA[포인터 타입에서 정수 타입으로 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 포인터가 정수로 변환될 때 요구되는 정수의 크기는 implementation-defined 이다. 포인터와 정수형 타입 간의 변환은 가능하면 피하는 것이 좋다. 단, 메모리 mapped 레지스터 또는 다른 하드웨어에서는 피할 수 없다. 또한, C++은 포인터에서 어떤 소수점 타입으로도 변환을 허용하지 않는다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_12_08_02</rule>
		<ruleTitle><![CDATA[추상 클래스에서 복사 대입 연산자는 protected 또는 private으로 선언되어야 한다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 추상 클래스는 상속에서 인터페이스 부분을 표현한다. 이런 상속 관계에서 최상위 복사 생성자를 호출하게 된다면 그 하위 클래스들에서 구현해 놓은 구현체들은 무시한 채 기본 클래스의 객체만 복사되게 된다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_05_03</rule>
		<ruleTitle><![CDATA[템플릿으로 작성된 복사 대입 연산자가 하나의 제네릭 파라미터를 갖는 경우, 복사 대입 연산자가 명시적으로 선언되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 일반적으로 복사 대입 연산자가 있는 경우, 컴파일러에 의해 자동으로 복사 대입 연산자가 생성되지 않는다. 그러나, 템플릿으로 생성된 복사 대입 연산자의 경우에는 여전히 자동으로 생성되기 때문에 개발자의 의도와는 다른 결과가 발생하게 된다. 따라서 템플릿으로 작성된 복사 대입 연산자가 하나의 제네릭 파라미터를 갖는 경우, 복사 대입 연산자가 명시적으로 선언되어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_05_01</rule>
		<ruleTitle><![CDATA[non-member 제네릭 함수는 associated namespace 가 아닌 namespace 에서 선언되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Argument-dependent lookup (ADL) 은 함수 호출을 처리할 때, 함수를 찾기 위한 찾기-범위(search-scope) 이외에도 associated namespaces 를 추가로 포함한다. 때문에 이 추가 namespace 가 오버로드 식별(overload resolution) 결과에 영향을 줄 수 있다. 이것이 개발자의 의도와는 다를 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_05_02</rule>
		<ruleTitle><![CDATA[템플릿으로 작성된 생성자가 하나의 제네릭 파라미터를 갖는 경우, 복사 생성자가 명시적으로 선언되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 일반적으로 복사 생성자가 있는 경우, 컴파일러에 의해 자동으로 복사 생성자가 생성되지 않는다. 그러나, 템플릿 생성자의 경우에는 여전히 복사 생성자가 자동으로 생성되기 때문에 개발자의 의도와는 다른 결과가 발생하게 된다. 따라서 템플릿으로 작성된 생성자가 하나의 제네릭 파라미터를 갖는 경우, 복사 생성자가 명시적으로 선언되어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_06_01</rule>
		<ruleTitle><![CDATA[goto 문장이 참조하는 label은 같은 block이나 goto 문장을 포함한 block에 선언해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 goto를 분별 없이 사용한 프로그램은 이해하고 분석하기 어렵다. C++에서는 unspecified behaviour를 유발할 수 있다. 하지만 goto를 아예 사용하지 않으면 flag를 사용해야 하는 제어 흐름이 있고 goto를 대체해서 사용한 flag가 오히려 더 명확하지 않을 수 있다. <br/><br/>그러므로 goto를 제한적으로 사용하여 개발자의 기대하는 결과를 얻을 수 있으면 허용한다. 복잡한 제어 흐름을 유발하기 때문에 내부 block으로 도약하면 안 된다 ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_06_02</rule>
		<ruleTitle><![CDATA[함수 body안의 label 선언은 goto보다 나중에 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 goto를 분별 없이 사용한 프로그램은 이해하고 분석하기 어렵다. C++에서는 unspecified behaviour를 유발할 수 있다. 하지만 goto를 아예 사용하지 않으면 flag를 사용해야 하는 제어 흐름이 있고 goto를 대체해서 사용한 flag가 오히려 더 명확하지 않을 수 있다. 그러므로 goto를 제한적으로 사용하여 개발자의 기대하는 결과를 얻을 수 있으면 허용한다. 반복문이 잘 정의된 언어에서 반복을 위해 뒤로 도약하면 안 된다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_04_10_02</rule>
		<ruleTitle><![CDATA[Literal 0을 null-pointer-constant로 사용하지 마라. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서 literal 0은 상수 타입이면서 null-pointer-constant이다. 개발자는 NULL을 null-pointer-constant로도 혹은 정수 0으로 의도하고 사용할 수 있다. 0은 정수로 취급해야 한다. 
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_06_05</rule>
		<ruleTitle><![CDATA[함수는 하나의 종료 지점만 함수의 끝에 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 구조화된 프로그램을 만들려면 함수의 종료 지점 수를 제한해야 한다. IEC 61508[12]에서 모듈화를 위해 요구한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
function-try-block으로 구현되어 try block와 catch 핸들러에 각 종료 지점이 여러개 있는 경우는 허용한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>IEC 61508 [12] Part 3 Table B.9]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_04_10_01</rule>
		<ruleTitle><![CDATA[NULL을 정수로 사용하지 마라. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서 literal 0은 상수 타입이면서 null-pointer-constant이다. 개발자는 NULL을 null-pointer-constant로도 혹은 정수 0으로 의도하고 사용할 수 있다. NULL은 pointer 타입으로 취급해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_06_03</rule>
		<ruleTitle><![CDATA[continue 문장은 잘 쓰여진(well-formed) for 루프에서만 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 continue 문장을 과도하게 사용하면 코드를 복잡하게 한다. 복잡한 코드는 테스트해야 하는 다른 logic의 테스트를 방해한다. 필요한 테스트가 제어 흐름에 따라 이루어지지 않을 수 있다. 잘 쓰여진 for 루프는 규칙 06_05_01과 규칙 06_05_06을 만족한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_06_04</rule>
		<ruleTitle><![CDATA[반복문은 하나의 break나 goto로만 종료해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 구조화된 프로그램을 만들려면 루프의 종료문의 수를 제한해야 한다. 두 결과가 나올 수 있는 루프나 최적화 코딩을 위해 루프에서 break나 goto 문은 하나만 허용한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_21</rule>
		<ruleTitle><![CDATA[이항 비트 연산의 피연산자들은 모두 같은 부호 없는(unsigned) 근본타입(underlying type)을 가져야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 비트 연산은 보통의 경우 부호 비트를 다루는 연산을 수행하지 않는다. 또한 표준에서 언급한 것처럼 음수 값에 대한 >> 연산은 컴파일러마다 그 결과가 다르다. 따라서 비트 연산자를 사용할 때 반드시 근본타입이 부호가 없는 타입만 사용해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_20</rule>
		<ruleTitle><![CDATA[이항 비트 연산의 상수가 아닌 피연산자들은 모두 같은 근본타입(underlying type)을 가져야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 비트 연산은 보통의 경우 같은 비트수를 같은 피연산자간에 이루어진다. 이것을 보장하기 위해 상수가 아닌 피연산자가 비트 연산에 사용될 때에는 반드시 근본타입이 동일하게 유지해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_18</rule>
		<ruleTitle><![CDATA[포인터간의 대소 비교는 같은 배열에 대한 요소 간에 이루어져야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 포인터간의 대소 비교 시에 같은 배열을 참조하지 않는 경우 결과값이 실행마다 달라질 수 있다. 따라서 이러한 방법으로 목적한 결과를 얻으려는 시도는 지양해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_17</rule>
		<ruleTitle><![CDATA[포인터 차감 연산은 같은 배열에 대한 요소간에 이루어져야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
이 규칙은 다음의 표현식에 적용한다:<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;pointer_expression_1 - pointer_expression_2<br/><br/>
pointer_expression_1 와 pointer_expression_2 는 배열 요소를 가리킨다.<br/><br/>
pointer_expression_1 와 pointer_expression_2 가 같은 배열의 요소를 가리키지 않거나 배열의 끝을 넘어서 가리키는 경우, 이는 정의되지 않은 행동이다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_19</rule>
		<ruleTitle><![CDATA[3차원 이상의 포인터 선언 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 2차원 이상의 포인터 선언은 가독성과 유지보수성을 심히 해치므로 사용하지 않는 것이 좋다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_03</rule>
		<ruleTitle><![CDATA[cvalue 표현식(expression)의 근본 타입(underlying type)을 다른 타입으로 묵시적 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 cvalue 는 정의에 의해, 기본 변환이 더 이상 일어나지 않는 값을 의미한다(MISRA C 에서는 complex expression 이라 정의했다). 근본 타입은 이 cvalue 의 것을 따르게 된다. MISRA 에서의 모든 연산은 근본 타입이 바뀌지 않는 상태에서 완료되어야 한다. 서로 다른 타입간의 묵시적 변환은 프로그램의 잠재적인 오류가 될 수 있으며, 일반적인 개발자들은 이것을 발견하기가 어렵다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_02</rule>
		<ruleTitle><![CDATA[표현식(expression)에서 C++ 연산자 우선순위 규칙을 변경하고자 할 때에만 괄호를 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  기본적인 연산자 우선순위와 동일하게 추가적인 괄호를 사용하는 경우, 괄호는 이를 강조하는 의미로 사용될 수 있다. 이는 C++의 복잡한 우선순위 규칙을 사용하여 발생할 수 있는 실수들을 방지할 수 있으며 코드를 읽기 쉽게 만들어준다. 그러나 너무 많은 괄호들은 코드를 읽기 힘들게 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_05</rule>
		<ruleTitle><![CDATA[부동소수 타입과 정수 타입 사이의 묵시적 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 부동 소수점 타입을 정수형 타입으로 변환하면 값이 부정확해지며, 만약 변환 후의 값을 정수형 타입으로 표현할 수 없는 경우, 정의되지 않은 행동(undefined behavior)을 발생시킨다. <br/><br/>정수형으로의 변환이 꼭 필요한 경우라면 캐스팅연산자를 사용하여 명시적으로 변환해서 사용할 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_04</rule>
		<ruleTitle><![CDATA[근본 타입(underlying type)의 부호를 변경하는 묵시적 정수 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 부호 있는 타입으로부터 부호 없는 타입으로의 변환은 대부분 프로그래머의 실수 이다. 경우에 따라서 이러한 변환은 정상적으로 작동하는 것처럼 보이겠지만 실제로는 컴파일러에 의해 정의된 동작(implementation-defined behavior) 이 발생되는 것임을 알아야 한다. 이 것은 개발자의 예상과 다를 수 있으므로 매우 위험하다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_01</rule>
		<ruleTitle><![CDATA[모든 표현식의 계산 값은 표준에 따른 어떤 평가 순서로 평가하여도 그 값이 같아야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 '&&', '||', '? :', ',' 같은 연산자를 제외한 다른 연산자들의 경우 하위 표현식(sub-expression)의 평가 순서는 표준에 의해 정의되지 않았기 때문에, 컴파일러마다 다른 계산 순서를 가질 수 있다. 이는 하위 표현식들의 계산 순서를 신뢰할 수 없다는 것이며 특히 어떠한 부작용(side-effect)이 발생할지 미리 예측하기 어렵다.
<br/><br/>
 평가 순서에 대한 문제는 어떤 것이 먼저 평가되느냐에 대한 문제가 아니기 때문에 괄호를 쓴다고 하여 해결할 수 있는 문제가 아님을 기억해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_08_04_02</rule>
		<ruleTitle><![CDATA[함수 재 선언 시 이전 선언과 동일한 식별자를 갖는 파라미터를 써야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 파라미터 이름은 그 함수 정의에서 파라미터의 목적을 설명하는데 도움을 준다. 만일 함수 파라미터의 재 선언 시 다른 이름으로 선언되면 개발자가 혼란스러워 할 수 있다. 이 규칙은 overriding set(virtual 함수와 모든 overriding 함수들)에 대해서도 적용된다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
선언 또는 재 선언 시 unnamed 파라미터를 포함한 경우 위배가 아니다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_02_01</rule>
		<ruleTitle><![CDATA[객체를 자신과 겹쳐지는 객체로 할당 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
물리적 공간을 공유하는 객체들 간에 서로를 할당하면 정의되지 않은 동작을 할 가능성이 있다. 
<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 9–5–1]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_08_04_01</rule>
		<ruleTitle><![CDATA[가변인자를 갖는 함수 정의 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 가변인자를 사용하면 컴파일러 타입 검사를 건너 뛴다. 게다가 non-POD 타입 인자를 전달하면 undefined behaviour가 발생한다. 이 규칙은 "정의"("선언"이 아님) 라고 명시하고 있다. 따라서 라이브러리 함수들은 규칙의 대상에서 제외한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_08_04_04</rule>
		<ruleTitle><![CDATA[함수 이름은 호출이나 & 다음에 쓸 때만 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 함수 이름(식별자)는 함수 포인터로 묵시적 변환 가능하다. 특정 상황에서 문제가 발생하지 않으면 개발자의 생각과 반대일 수 있다. 예를 들어 만일 개발자가 if (f) 라고 썼을 때, 이게 함수 f의 주소가 NULL인지 검사하기 위한 코드인지, 아니면 f()를 호출하려고 했는데 실수로 괄호가 빠진 것인지가 명확하지 않다. & 연산자를 쓰면 이렇게 모호한 경우가 해결된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
함수를 참조로 전달하거나 참조 객체에 할당하는 것은 위배가 아니다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_08_04_03</rule>
		<ruleTitle><![CDATA[Non-void 함수의 모든 exit path에는 명시적인 반환 수식이 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Non-void 함수에 반환 수식이 없으면 undefined behaviour이다. (컴파일러는 대부분 오류를 내지 않는다.) 보통의 경우 path 상에 마지막으로 실행된 문장의 계산 결과가 반환된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
이 규칙은 예외 핸들링으로 끝나는 경우( 즉, throw 문 )에는 적용하지 않는다.
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_14</rule>
		<ruleTitle><![CDATA[?: 연산자의 첫번째 피연산자는 bool 타입만 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C 와는 다르게 C++ 은 bool 타입이 새로 추가되었다. 하지만 legacy 코드와의 호환성을 위해 조건문은 bool 타입 대신에 정수형 타입의 값을 0 과 비교하는 방식을 사용할 수도 있다. ?: 연산자의 조건문에 bool 타입을 사용하면 코드 읽기와 유지보수가 수월해진다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_13</rule>
		<ruleTitle><![CDATA[조건문과 반복문 등에 사용된 조건들의 최종 결과타입은 bool 이어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C 와는 다르게 C++ 은 bool 타입이 새로 추가되었다. 하지만 legacy 코드와의 호환성을 위해 조건문은 bool 타입 대신에 정수형 타입의 값을 0 과 비교하는 방식을 사용할 수도 있다. 조건문에 bool 타입을 사용하면 코드 읽기와 유지보수가 수월해진다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
조건식에 단일 값을 할당하는 식이 들어있는 경우는 이 규칙에서 검출하지 않는다. 
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_16</rule>
		<ruleTitle><![CDATA[포인터 피연산자와 포인터 산술의 결과로 생긴 피연산자를 가리키는 포인터는 배열의 범위안의 원소를 가리켜야함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙은 다음과 같은 표현식에 적용된다 :<br/><br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- integer_expression + pointer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- pointer_expression + integer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- integer_expression + pointer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- ++pointer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- pointer_expression++<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- --pointer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- pointer_expression--<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- pointer_expression [ integer_expression ]
<br/><br/>
 포인터가 배열 범위를 벗어나 가리키면 예기치 않은 오류가 발생할 수 있고, 이는 정의되지 않은 행동이다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 5-0-15]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 포인터 연산들 중 오직 배열 접근만 사용하여야 한다. 이것이 포인터 조작에 비해 더 명확하고, 따라서 에러를 적게 발생시키기 때문이다. 이 규칙은 포인터 값들에 대한 명시적 산술을 금지시킨다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
배열을 가리키는 포인터에 의한 iterator에서의 증감 연산자 사용은 허용한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 0-3-1, Rule 5-0-16
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_10</rule>
		<ruleTitle><![CDATA[비트 연산자 ~ 와 << 를 unsigned char 또는 unsigned short 을 근본타입(underlying type)으로 갖는 피연산자에 사용하면 결과를 반드시 원래의 근본타입으로 명시적 변환해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 ~와 <<가 작은 정수 타입에 사용된 경우 이 연산은 정수 승격(integer promotion) 변환에 의해 signed int 환경에서 사용되고 그 결과값은 예상치 못한 높은 차수의 bits들을 포함할 수 있다. 따라서 개발자가 의도하지 않은 값이 될 수 있다. 
<br/><br/>
 <span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
unsigned char 또는 unsigned short 타입을 피연산자로 가지는 ~ 연산 또는 << 연산에 의해 얻는 결과 값을 같은 underlying type으로 바로 할당하는 경우(함수의 인자 또는 리턴값을 포함)는 그 변환이 묵시적이더라도 허용한다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_12</rule>
		<ruleTitle><![CDATA[부호 있는 char 타입은 숫자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙은 MISRA_CPP_05_00_11 와 비슷하지만 만약 문자 대신 숫자를 저장하기 위한 용도로 사용하기 위해서는 부호 있는 char 타입을 사용하길 권고한다. plain char 타입의 부호 여부는 컴파일러마다 다르며, 이 타입에 표준에 정의된 문자가 아닌 정수 값을 저장하는 것은 원래의 목적을 위배한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 3-9-2, Rule 5-0-11]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 plain char 타입의 부호 여부는 컴파일러마다 다르며, 이 타입에 표준에 정의된 문자가 아닌 정수 값을 저장하는 것은 원래의 목적을 위배한다. 8비트의 저장공간이 필요한 경우 명시적인 부호 여부를 포함하여 적절한 타입 재정의를 통해 새로운 타입을 도입하여 사용하는 것이 더 낮다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 3-9-2, Rule 5-0-12]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_07</rule>
		<ruleTitle><![CDATA[cvalue 표현식(expression)의 근본타입(underlying type)이 변하는 부동소수형과 정수형간의 명시적 변환금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 대부분의 경우, cvalue 표현식에 적용된 명시적 변환은 cvalue 자체의 계산에는 영향을 미치지 않는다. 따라서 이러한 명시적 변환은 불필요하다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_06</rule>
		<ruleTitle><![CDATA[정수형이나 부동소수형의 근본 타입(underlying type)의 크기를 줄이는 묵시적 형변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 타입의 크기가 줄어들게 되면, 값의 정확도가 손실되므로 개발자가 원하는 값을 얻을 수 없게 된다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_09</rule>
		<ruleTitle><![CDATA[cvalue 표현식(expression)의 정수형 근본타입(underlying type)의 부호를 변경하는 명시적 정수 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 부호 있는 타입으로부터 부호 없는 타입으로의 변환은 대부분 프로그래머의 실수 이거나 개발자의 예상과 다를 수 있으므로 사용을 자제한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_03_01</rule>
		<ruleTitle><![CDATA[단일 매크로 정의에서 # 또는 ## 연산자는 최대 한 개만 존재해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #과 ## 전처리 연산자의 evaluation 순서는 명시되어있지 않다. 어떤 단일 매크로 정의에서도 한 번만 사용한다면 이 문제는 발생하지 않는다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_00_08</rule>
		<ruleTitle><![CDATA[cvalue 표현식(expression)의 근본타입(underlying type)의 크기를 증가시키는 정수형과 부동소수형간의 명시적 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 대부분의 경우, cvalue 표현식에 적용된 명시적 변환은 cvalue 자체의 계산에는 영향을 미치지 않는다. 따라서 이러한 명시적 변환은 불필요하다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_03_02</rule>
		<ruleTitle><![CDATA[#과 ## 연산자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #과 ## 전처리 연산자의 evaluation 순서는 명시되어있지 않다. 컴파일러는 이러한 연산자를 일관되게 실행하지 않으므로, 사용하지 않는다면 이러한 문제를 피할 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_04_03</rule>
		<ruleTitle><![CDATA[부동소수점(floating point) 연산의 표준 준수 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
Floating-point 연산은 다양한 표준 연산들이 있다. 표준 연산은 [1] 표준에 기술된 방법에 따라 개발되고 테스트 되어야 하며 이것들을 제대로 지키지 않으면  다양한 문제들이 나타날 수 있다. 
<br/>
<br/>
<b>참고 문헌</b><br/>
[1] IEEE Standard for Binary Floating-Point Arithmetic," ANSI/IEEE Std 754-1985 , vol., no., pp.0_1,, 1985
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_04_02</rule>
		<ruleTitle><![CDATA[부동소수점(floating point) 연산 문서화 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Floating-point 연산의 사용은 높은 레벨의 숫자 분석 능력, 컴파일러와 target 하드웨어에 대한 철저한 지식을 요구한다.

<br/>
<br/>
<b>참조 논문</b><br/>
[1] David Goldberg, 'What Every Computer Scientist Should Know about Floating-Point Arithmetic', Xerox Palo Alto Research Center, Palo Alto, CA, 1991
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_04_01</rule>
		<ruleTitle><![CDATA[Scaled-integer나 고정 소수점(fixed point) 연산 문서화 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
가능한 모든 케이를 고려하면서 scaled-integer 또는 fixed-point 연산을 위한 연산 패키지를 디자인하고 구현하는 것은 굉장히 어려운 일이다. 둘 중 하나를 사용한다면, 이 규칙은 모든 이슈가 구현에 의해 커버된다는 것을 증명하는 문서를 만들기를 요구한다. 
<br/><br/>
]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_04_06</rule>
		<ruleTitle><![CDATA[switch 문의 마지막 절은 default이어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 마지막에 default-clause 를 사용하여 방어적으로 프로그래밍해야 한다. 또한 이 절에서는 적절한 행동이 있어야 하고 없는 경우에는 주석으로 이유를 명시해야 한다.  
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
switch 문의 조건식이 enum 타입이고 모든 enum 타입을 case label에 명시했으면 default-clause는 필요하지 않다. 이 경우에도 default-clause를 쓰는 것은 방어적 프로그래밍이므로 괜찮다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_04_05</rule>
		<ruleTitle><![CDATA[비어 있지 않은 switch-clause는 throw나 break로 종료되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 개발자가 switch-clause의 끝에 break를 넣지 않으면 다음 switch-clause를 진행한다(fall through). 가끔 이것이 오류인 경우도 있다. 이런 행동이 오류인 경우에는 모든 switch-clause 는 break이어야 하고 switch-clause가 복합문이면 마지막 문장은 break이어야 한다. 여러 절이 같은 문장으로 구성될 때는 빈 switch-clause를 사용하는 경우는 예외이다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_04_08</rule>
		<ruleTitle><![CDATA[모든 switch 문에는 적어도 하나의 case-clause가 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  case 절이 없는 switch 문장은 불필요한 코드다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_04_07</rule>
		<ruleTitle><![CDATA[switch문의 조건식에 boolean expression 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 boolean expression은 switch 문보다 if 문에 쓰는 것이 낫다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_04_02</rule>
		<ruleTitle><![CDATA[모든 if, else if 문장은 else 절로 끝나야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 if 문에 하나 이상의 else if 문이 존재하면 반드시 else 절로 끝나야 한다. simple if 문의 경우는 else 문이 없어도 된다. 방어적으로 프로그래밍하려면 마지막 else 절에서는 적절한 동작이 있거나 동작이 없으면 알맞은 주석이 있어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 if, else if, else 문장의 body가 복합문(compound statement)이 아니면, 개발자가 한 문장인 body를 여러 문장인 body로 바꾸려 할 때 괄호를 사용하지 않아 오류가 발생할 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_04_04</rule>
		<ruleTitle><![CDATA[switch-label은 switch 문장의 body의 block scope에 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 switch-label이 switch 문장 body의 아무 곳에나 있으면 코드의 구조가 깨질 수 있다. case-label 이나 default-label의 scope가 switch 문장의 body 이면 방지할 수 있다. 모든 case-clauses와 default-clause는 같은 scope이어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_04_03</rule>
		<ruleTitle><![CDATA[switch 문의 형태는 잘 쓰여야(well-formed) 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++ 표준의 switch 구문은 제약이 적어 복잡한 코드를 만들고 문장 사이의 구조가 깨질 수 있다.  MISRA C++ 에서 정의한 switch 구문 형식을 따르면 문장이 간단하고 일관된 구조를 가진다.. switch문에서 goto 문을 사용할 때는 goto문과 label이 같은 scope에 있어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_10_01_03</rule>
		<ruleTitle><![CDATA[접근 가능한 base 클래스가 다중 상속 계층에 virtual, non-virtual로 존재하면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 만약 base class가 다중 상속 관계에서 virtual, non-virtual로 존재할 때, 상속된 객체에는 해당 base class의 객체 사본이 최소한 두 개 이상 존재하게 된다. 이는 개발자의 의도와 다를 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_10_01_02</rule>
		<ruleTitle><![CDATA[클래스는 다이아몬드 상속 관계일 때에만 다른 클래스를 virtual로 상속받아야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 클래스를 virtual로 상속받는 것은 다수의 undefined behavior를 발생시킬 수 있다. 따라서 이를 사용하지 말아야 하되 예외적으로 다이아몬드 상속 관계에서 공통된 base로 사용되는 클래스만 virtual로 상속받아 사용하는 것을 허용한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_10_01_01</rule>
		<ruleTitle><![CDATA[클래스는 다른 클래스를 virtual로 상속받지 않아야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 클래스를 virtual로 상속받는 것은 다수의 undefined behavior를 발생시킬 수 있으며 따라서 잠재적으로 혼동을 주는 동작을 할 수 있다. 따라서 다른 클래스를 virtual로 상속하는 것은 권장되지 않는다. 

<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 5–2–2, Rule 10–1–2, Rule 12–1–2]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_02_01</rule>
		<ruleTitle><![CDATA[character set과 encoding을 문서화해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 소스 코드는 character set으로 이루어진다. character set 을 문서화하면 개발자의 주의를 환기하여, 호환되지 않는 character set을 사용하여 발생하는 문제를 예방할 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_01_02</rule>
		<ruleTitle><![CDATA[#else, #elif, #endif 모두 #if 또는 #ifdef와 같은 파일에 위치해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 문장의 포함과 제외가 전처리 지시자로 제어될 때, 모든 관련 있는 지시자가 한 파일에 존재하지 않으면 개발자가 혼동할 수 있다. 이 규칙은 #if/#ifdef ... #elif ... #else ... #endif 형태의 모든 전처리 지시자는 같은 파일에 존재하기를 요구한다. 이 규칙을 준수하면 좋은 코드 구조를 지킬 수 있고 유지보수 문제를 피할 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_01_01</rule>
		<ruleTitle><![CDATA[defined 전처리 연산자는 두 가지 표준 형태 중 한 가지로 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 define(identifier), defined identifier 의 두 가지 defined 연산만 허용한다. 다른 형태는 제한되는 위배사항이지만 모든 컴파일러가 잡아내는 것은 아니다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_02_01</rule>
		<ruleTitle><![CDATA[모든 변수나 함수의 선언은 호환되는 타입을 가져야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 다른 두 translation unit에서 객체나 호환되지 않는 타입의 객체나 함수 선언이 있으면 정의하지 않은 행동(undefined behaviour)이다.
<br/><br/> 객체나 함수 선언의 타입을 호환되게 하는 가장 쉬운 방법은 동일하게 선언하는 것이다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 3–9–1]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_02_03</rule>
		<ruleTitle><![CDATA[여러 translation unit에서 사용하는 변수나 함수는 한 파일에서 한 번만 선언해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
한 타입의 단일 선언을 가질때, 컴파일러는 함수 또는 객체에 대하여 같은 요소에 대해서 호환되지 않는지 감지할 수 있다.<br/><br/>
 일반적으로 헤더 파일의 외부 식별자(external identifier)를 선언하고 이를 include하여 정의하거나 사용해야 여러 파일에 동일한 외부 식별자를 선언하면 컴파일러는 타입이 호환되지 않을 때 오류를 발견하지 못할 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_02_02</rule>
		<ruleTitle><![CDATA[One Definition Rule을 지켜야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 One Definition Rule을 어기면 정의하지 않은 행위를 유발한다. 일반적으로 프로그램에는 inline이 아닌 함수나 객체는 한 번만 정의해야 한다. <br/><br/>
덧붙여 타입, 템플릿, inline 함수의 정의는 같은 토큰(token)으로 구성되어야 한다. 
<br/><br/>이 규칙에서는 typedef는 타입으로 취급한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_02_04</rule>
		<ruleTitle><![CDATA[external linkage 식별자의 중복 정의 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 서로 다른 translation unit에서 식별자를 정의하거나 모두에서 정의가 없는 것은 정의하지 않은 행위이다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_10_03_01</rule>
		<ruleTitle><![CDATA[상속 계층을 따라 각 virtual function의 정의는 하나씩만 존재해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙의 주 목적은 유지보수자와 리뷰어들에게 명확성을 제공하는 데 있다. 클래스 상속의 어떤 지점에서도 한 클래스의 function이 수행됨을 보장함으로써 애매함을 없앨 수 있다. 부수적으로, 클래스들이 다이아몬드 상속관계를 가지고 있다면, call by dominance에 의해 개발자의 의도와 다른 함수를 호출할 수 있기에 위험하지만 이 규칙을 통해 이러한 call by dominance를 방지한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
소멸자는 클래스 계층 구조의 여러 멤버 내 에서 virtual로 선언될 것이다.<br/>
만약 함수가 순수 함수로 선언되어있고 같은 클래스 내에 정의되어 있다면, 이 규칙에서 그 정의는 무시된다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_10_03_02</rule>
		<ruleTitle><![CDATA[virtual 함수를 상속받은 함수에 virtual 속성을 명시해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 virtual 함수를 상속받을 때에는 virtual 키워드를 사용하여 해당 함수가 virtual이었는지 base 클래스를 확인해보아야 하는 필요성을 없애야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_10_03_03</rule>
		<ruleTitle><![CDATA[재 선언되는 base 클래스의 함수가 pure virtual일 때만 pure virtual 함수로 재 선언할 수 있음 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 어떠한 함수를 pure virtual로 다시 선언하는 것은 개발자의 의도에 부합되지 않을 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_12_01_03</rule>
		<ruleTitle><![CDATA[하나의 기본 타입의 매개변수를 갖는 호출 가능한 생성자들은 explicit으로 선언되어야 한다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 explicit 키워드는 생성자가 기본 타입을 클래스 타입으로 암시적으로 변경하는 것을 막는다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_12_01_01</rule>
		<ruleTitle><![CDATA[객체의 동적 타입은 생성자나 소멸자 안에서 사용되지 않아야 한다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 어떤 객체의 생성이나 소멸 중에 해당 객체의 최종 타입이 완전히 생성된 객체의 것과 다를 수 있다. 이 결과 객체의 동적 타입을 생성자 또는 소멸자에서 사용하는 것이 개발자의 의도와 다르게 될 수 있다.<br/>
객체의 동적 타입은 다음의 구조에서 사용된다 :<br/><br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- 가상함수를 가진 클래스에서의 typeid <br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- dynamic cast<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- 가상 함수의 가상 호출<br/><br/>
또한 이 규칙은 생성자 또는 소멸내 내에서 순수 가상함수가 호출되는 경우도 금지한다. 이 호출 또한 정의되지 않은 행동이다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_12_01_02</rule>
		<ruleTitle><![CDATA[클래스의 모든 생성자는 명시적으로 바로 위 기본 클래스의 생성자를 호출해야 한다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙은 어떠한 생성자가 사용되어야 하는지, 그리고 어떠한 매개 변수가 사용되어야 하는지에 대한 혼동을 줄여준다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_02_03</rule>
		<ruleTitle><![CDATA[전처리 전에, null statement는 다른 statement와 혼용 금지. null 문장 뒤에 주석이 올 때는 문장 바로 다음에 공백이 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 일반적으로 null 문장을 의도하여 사용하지 않아야 하지만, 사용할 경우에는 한줄씩 나타내야 한다.  null 문장 이전에 들여쓰기에 사용한 공백 문자가 있을 수 있다. null 문장 뒤에 주석이 따를 경우에는 공백문자가 있어야 한다.  코드를 보는 사람에게 표시해 주기 위해서 null 문장 다음에 공백 문자가 있고 주석이 있어야 한다. 이 규칙을 따르면 정적 분석 도구에서 null 문장과 다른 문자열이 같은 줄에 있을 때 프로그래밍의 오류를 경고해 줄 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_02_01</rule>
		<ruleTitle><![CDATA[sub-expression에서 할당 연산자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 sub-expression에서 할당 연산자를 사용하면 전체 표현식에 side effect를 유발할 수 있다. 잠재적으로 개발자가 기대하지 않은 결과값이 나올 수 있다. 또한 = 와 == 를 혼동하지 않도록 한다. <br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_02_02</rule>
		<ruleTitle><![CDATA[실수 표현식에 동등 비교 연산자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 실수형 타입끼리 비교 연산을 하면 기대한 것과 다른 결과가 발생할 수 있다. 또한 이런 비교는 결과를 예측할 수도 없으며 구현에 따라 달라진다. 미리 정의한 실수 타입에 맞는 비교 연산을 라이브러리로 구현하여 사용하는 것이 좋다.  라이브러리는 반드시 실수 타입의 최소 오차(std::numeric_limits<float>::epsilon())와 비교할 숫자의 범위를 고려해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_01_02</rule>
		<ruleTitle><![CDATA[명시적으로 NULL 을 던지면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 throw(NULL) 또는 throw(0) 은 포인터 형태로 던져지지 않고 int 핸들러로만 잡을 수 있다. 때문에, 개발자로 하여금 혼란을 야기시키며 포인터 타입의 예외만 핸들링하는 프로그램에서는 특히 더 헷갈리게 된다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_01_03</rule>
		<ruleTitle><![CDATA[빈 throw(throw;) 는 catch 핸들러에서만 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 빈 throw 는 예외 오브젝트로 표현된 임시 오브젝트에 대해 예외를 다시 던질 때 사용되며, 두 개 이상의 핸들러에 예외를 전파할 수 있게 한다. 그러나 C++ 언어의 구문상 throw; 를 catch 핸들러 외에 사용하는 것을 막을 방법이 없다. 이 경우 컴파일러마다 다른 결과가 나타난다(implementation-defined). 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_01_01</rule>
		<ruleTitle><![CDATA[throws 문장의 표현식 자체가 예외를 던지면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 예외 오브젝트를 생성하는 중에 예외를 던지거나, 예외 오브젝트의 초기화하는 표현식을 계산하는 중에 예외가 던져지면, 원래의 예외 오브젝트보다 여기에서 던져진 예외가 우선적으로 전파된다. 이로 인해 개발자의 의도와는 다른 예외가 전파될 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_02_01</rule>
		<ruleTitle><![CDATA[underlying type이 enum인 수식은 해당 enum에 속한 값들만 가져야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 underlying type이 enum인 수식이 해당 enum에 속하지 않은 값을 가지는 경우는 표준에 명시되지 않은 동작을 하게 된다. 따라서 enum 타입에 속하지 않은 값을 가지면 안 된다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[기타]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_14_01</rule>
		<ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++ 에서 표현식의 어떤 부분이 실행되지 않는 경우가 있다. 만약 이러한 하위 표현식이 side effect를 가진다면, 이들은 다른 하위 표현식의 값에 의존되어 실행이 될 수도 되지 않을 수도 있다. 이러한 문제를 일으키는 연산자는 && 와 || 이다. 여기서 오른쪽 피연산자의 실행은 왼쪽 피연산자의 값에 따라 달라진다. 논리 연산자 중 하나에서 오른쪽 피연산자의 조건적 실행은 개발자가 side effect가 발생하는 표현식을 사용한다면 쉽게 문제를 일으킨다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 5–2–11<br/>ISO/IEC 14882:2003 [1] §3.2(2), §5.14, §5.15]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_05_01</rule>
		<ruleTitle><![CDATA[클래스 소멸자는 예외를 발생하며 끝나면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 프로그램이 핸들링되지 않은 예외를 던지며 종료되는 경우, 컴파일러 마다 다른 결과를 나타낸다(implementation-defined). 특히, 스택이 종료직전에 풀려버리게되서 자동 생성된 변수들의 소멸자가 호출되지 않는 상황이 생길 수 있다. 소멸자안에서 예외가 발생되고 역시 그 안에서 핸들링할 수 있는 경우는 허용된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–1, Rule 15–3–3, Rule 15–5–3]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_05_02</rule>
		<ruleTitle><![CDATA[함수의 선언이 예외 기술절(exception-specification) 을 포함하면, 해당 함수는 이 예외 기술절에 언급된 타입의 예외만 발생시켜야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 함수 선언의 예외 기술절에 나타나지 않는 예외가 발생하면, unexpected( ) 라는 함수가 호출되고, 이 함수는 프로그램 내에서 특별한 일을 하도록 오버라이드 되어 있을 수도 있지만 기본적으로는 std::bad_exception 을 발생시킨다. 만약 예외 기술절에 이 예외가 나타나지 않았다면, 즉시 terminate() 가 호출되고 프로그램은 컴파일러마다 다른 결과를 가지며(implementation-defined) 로 종료된다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_05_03</rule>
		<ruleTitle><![CDATA[terminate() 함수는 묵시적으로 호출되면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 terminate() 함수가 호출되기 전에 스택이 풀리지 않으면, 자동 변수들의 메모리 소멸이 일어나지 않은 채로 종료된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–1, Rule 15–3–2, Rule 15–3–4, Rule 15–5–1. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_05_01</rule>
		<ruleTitle><![CDATA[digraph 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
   digraphs는 다음과 같다.<br/><br/>'<%, %>, <:, :>, %:, %:%:'<br/><br/>digraphs는 개발자의 의도와는 다를 수 있다. <br/><br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_08_00_01</rule>
		<ruleTitle><![CDATA[하나의 declaration에 declarator 하나만 쓰는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 하나의 declaration에 declarator가 여러 개 있으면 그 식별자의 타입이 개발자의 생각과 다를 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §9.2]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_18_01</rule>
		<ruleTitle><![CDATA[comma 연산자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 comma 연산자의 사용은 일반적으로 가독성을 해친다. 같은 동작을 하는 다른 방법이 존재하기 때문에 사용하지 않는 것이 좋다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_03_07</rule>
		<ruleTitle><![CDATA[try-catch 문장이나 function-try-block 에서 다중의 예외를 핸들링할때는 catch-all 핸들러는 가장 마지막에 나타나야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 catch-all 핸들러는 예외의 계층구조와 타입에 상관없이 모든 예외를 핸들링할 수 있기 때문에, 순서에 따라 이후의 핸들러가 도달 불가능한 코드가 될 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_03_06</rule>
		<ruleTitle><![CDATA[상속관계에 있는 클래스에 대한 try-catch 문장이나 function-try-block 에서 핸들링할때는 가장 하위 타입부터 상위타입 순서로 핸들러를 배치해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 핸들러에 상위 타입이 먼저 배치되는 경우, 타입 계층구조상에 있는 다른 하위 타입들은 상위타입으로 up-casting 이 될 수 있으므로 이 후의 하위 타입에 대한 핸들러는 도달불가능한 핸들러가 된다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_03_05</rule>
		<ruleTitle><![CDATA[클래스 타입의 예외는 항상 레퍼런스 방식으로 핸들링 해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 만약, 클래스 타입의 예외 오브젝트를 값으로 핸들링하게 되면, 잘림(slicing)이 발생한다. 만약, 상속관계에 있는 하위(derived) 타입의 예외가 발생하고, 핸들링은 상위(base) 타입으로 하게 되면, 상위타입의 함수(virtual 포함) 만 호출할 수 있고, 추가적인 멤버 데이터는 잘리기 때문에 사용할 수 없다. 이 경우 예외를 레퍼런스로 핸들링하면, 잘림현상은 나타나지 않는다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_03_04</rule>
		<ruleTitle><![CDATA[코드 내에서 명시적으로 예외를 발생시키는 경우, 이 함수의 호출 경로 상에 호환되는 타입의 핸들러가 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 처리되지 않은 예외가 있는 상태로 프로그램이 종료되면, 컴파일러 마다 다른 결과를 나타낸다(implementation-defined). 특히, 스택이 종료직전에 풀려서 자동 생성된 변수들의 소멸자가 호출되지 않는 상황이 생길 수 있다. 상속관계에 있는 예외가 던져지는 경우, 상위 클래스나 호환되는 다른 타입으로 핸들링할 수 있다. 이 규칙의 목적은 예상되는 모든 예외들을 모두 핸들링해야 한다는 것이다. 또한 예상하지 못한 예외는 MISRA_CPP_15_03_02 규칙을 적용하면 핸들링 할 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–2, Rule 15–5–3]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_03_03</rule>
		<ruleTitle><![CDATA[생성자나 소멸자를 function-try-block 으로 구현하는 경우, 핸들러에서 이 클래스나 베이스 클래스의 비-정적(non-static) 멤버를 참조하면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
   프로그램이 핸들링되지 않은 예외를 던지며 종료되는 경우, 컴파일러 마다 다른 결과를 나타낸다(implementation-defined). 특히, 스택이 종료직전에 풀려서 자동 생성된 변수들의 소멸자가 호출되지 않는 상황이 생길 수 있다. 이런 상황을 대비하기 위해 최후의 방어(last-ditch catch-all) 수단을 구축해야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–1, Rule 15–5–1]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_03_02</rule>
		<ruleTitle><![CDATA[핸들링되지 않은 예외들을 처리하는 예외핸들러가 최소한 하나는 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  프로그램이 핸들링되지 않은 예외를 던지며 종료되는 경우, 컴파일러 마다 다른 결과를 나타낸다(implementation-defined). 특히, 스택이 종료직전에 풀려서 자동 생성된 변수들의 소멸자가 호출되지 않는 상황이 생길 수 있다. 이런 상황을 대비하기 위해 최후의 방어(last-ditch catch-all) 수단을 구축해야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–4, Rule 15–5–3]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_03_01</rule>
		<ruleTitle><![CDATA[예외는 start-up(main) 다음 위치와 프로그램이 끝 바로 전에만 일으켜야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 start-up 또는 종료 시에 예외를 던지는 것은 컴파일러마다 다른 결과를 나타낸다(implementation-defined) 이다. main 이 시작되기 전에 static 오브젝트를 초기화 하거나, main 이 반환된 후에 static 오브젝트가 소멸 되는 것이 문제가 된다. 표준에도 언급되어 있지만, 그렇다고 main 을 function-try-block 으로 만들어도 이 문제는 해결되지 않으며, catch 할 수 있는 방법이 없다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–3, Rule 15–3–4, Rule 15–5–1, Rule 15–5–3]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_11_00_01</rule>
		<ruleTitle><![CDATA[POD가 아닌 class에서의 member data는 private이어야 한다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 멤버 함수와 같은 클래스 interface를 구현함으로써 구현체는 어떠한 객체의 상태가 어떻게 변경되는지, 그리고 client에 의한 영향으로부터 class의 정보들이 어떻게 유지되는지를 더욱 명확히 조절할 수 있게 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_05_01</rule>
		<ruleTitle><![CDATA[함수는 함수 내 정의된 변수에 대한 참조나 포인터를 반환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이러한 자동 변수들은 함수 호출이 끝날 때 소멸되게 된다. 이 변수들에 대한 포인터나 참조를 반환하면 해당 변수들이 소멸된 이후에 사용될 수 있으므로 오류가 발생할 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_05_02</rule>
		<ruleTitle><![CDATA[자동 변수의 주소는 그 변수가 소멸된 이후에도 지속되는 다른 변수에 할당 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 자동 변수의 주소가 더 큰 scope의 자동 변수, 또는 static 변수에 할당되거나 함수에서 반환되면 그 주소를 갖고 있는 객체는 원본 객체가 소멸된 시점 이후에 사용될 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_05_03</rule>
		<ruleTitle><![CDATA[함수는 const 참조로 전달된 파라미터에 대한 포인터나 참조 반환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 참조형 파라미터가 임시 객체를 가리킬지 아니면 파라미터로 전달받은 그 객체를 가리킬지에 대한 동작은 구현체마다 다르다. 만약 어떠한 구현체에서 이 참조형 파라미터가 전달받은 파라미터의 임시 객체를 가리키고 있는 경우, 이를 반환할 때 해당 객체가 소멸하여 잘못된 값을 전달하게 될 것이다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_05_04</rule>
		<ruleTitle><![CDATA[함수의 직, 간접적 재귀 호출은 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 제한되지 않은 재귀 호출은 stack overflow를 발생시킬 수 있다. 모든 재귀 호출은 반복 알고리즘으로 구현할 수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_07_01</rule>
		<ruleTitle><![CDATA[C 스타일 주석 안에서 C 스타일 내부 주석 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
    일부 확장을 제외하고 C++에서는 C 스타일 주석 안에서 내부 주석을 지원하지 않는다. '/*' 로 시작한 주석은 첫 번째 '*/'문자를 만날 때까지 유효하다.  <br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 주석은 소스에서 제거하지 않은 코드의 상태만 설명해야 한다. 주석 처리한 코드 뭉치는 코들를 관리할 때 혼란을 줄 수 있다. 더 나은 방법은 소스 코드의 변한 기록을 남기는 것이다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 2–7–2]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_07_02</rule>
		<ruleTitle><![CDATA[코드 뭉치를 C 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
     C 스타일 주석은 내부 주석을 지원하지 않기 때문에 이미 주석이 존재하는 코드 뭉치를 주석 처리하면 위험할 수 있다. 주석은 소스에서 제거하지 않은 코드의 상태만 설명해야 한다. 주석 처리한 코드 뭉치는 코드를 관리할 때 혼란을 줄 수 있다. 더 나은 방법은 소스 코드의 변한 기록을 남기는 것이다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 2–7–1, Rule 2–7–3]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_09_06_01</rule>
		<ruleTitle><![CDATA[bit들의 절대적인 위치를 표현하는 bit-field가 필요할 때에는 이것의 동작 및 packing이 문서화되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 bit-field의 몇몇 부분들은 implementation-defined이다. 특히 개발자는 다음의 내용이 implementation-defined임을 알아야 한다.<br>
<br> &nbsp;&nbsp;&nbsp;&nbsp;- bit-field가 저장될 때 높은 차수의 bit가 먼저 할당이 될지, 혹은 낮은 차수의 bit가 먼저 할당이 될지의 여부
<br> &nbsp;&nbsp;&nbsp;&nbsp;- bit-field끼리 storage unit boundary에 overlap  될수 있는지의 여부
<br> &nbsp;&nbsp;&nbsp;&nbsp;- 6-bit bit-field와 4-bit bit field를 순서대로 선언하였을 때 4-bit bit-field가 새로운 byte에서 시작할지, 아니면 앞의 선언에서 남은 2bit를 채워서 사용할지의 여부
<br><br> 이것들은 대부분(짧은 길이의 데이터를 저장할 때 공간을 효율적으로 쓰기 위한 경우들) 문제가 없으나 만약 bit-field의 정확한 위치가 중요하다면(하드웨어 레지스터에 접근하는 경우) 에러를 발생시킬 수 있다.<br>
<br> structure의 element에 접근은 오직 이름으로만 해야 하며 개발자는 구조체에서 bit-field가 저장되는 방법에 대한 가정을 하면 안 된다.<br> 규칙 3-9-2는 bit-field의 길이가 명시적으로 기록되어 있지 않는 한 bit-field를 정의하는 데 적용되지 않아도 된다.<br><br>
 만약 컴파일러가 bit-field를 특정 layout에 따라서 저장할 수 있게끔 하는 옵션이 있다면 이 옵션은 필히 문서화 되어야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_09_06_02</rule>
		<ruleTitle><![CDATA[bit 필드들은 bool, unsigned 또는 signed int의 타입들로만 구성되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 bit 필드들은 bool, unsigned 또는 signed int의 타입들로만 구성되어야 한다. bit 필드에서 부호 여부가 명시되지 않은 int 타입은 signed int, unsigned int 중 어떠한 타입을 사용해야 할지 모호한 데다가 구현체마다 사용되는 타입이 다르기 때문이다. 마찬가지로 plain char 타입 또한 부호 여부가 명확하지 않으므로 사용치 않아야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_09_06_03</rule>
		<ruleTitle><![CDATA[bit 필드에는 enum 타입의 변수가 포함되면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 enum 타입은 ISO/IEC 14882:2003에 부호 여부가 명시되어 있지 않다. 따라서 어떠한 enum 타입의 값을 표현하는데 몇 개의 bit가 필요한지를 결정할 수가 없기 때문에 이를 bit 필드에 사용하면 안 된다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_09_06_04</rule>
		<ruleTitle><![CDATA[부호 있는 integer 타입의 이름 있는 bit 필드의 크기는 1bit 이상이어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 1bit 크기의 signed int bit 필드는 실제로는 어떠한 값도 저장할 수 없기 때문에 개발자의 의도와 다르게 구현된 코드일 것이다. anonymous(이름 없는) 필드는 그 자체를 개발자가 의도하였을 수 있기 때문에 무시한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_19_03_01</rule>
		<ruleTitle><![CDATA[에러 표시자(indicator) errno는 사용하면 안 된다 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++의 기능인 errno는 이론적으로 유용하나 실질적으로는 표준에 따라 잘 정의되지 않았다. 0이 아닌 값이 어떤 문제를 가리킬 수도 가리키지 않을 수도 있기 때문에 errno는 사용하면 안 된다. 비록 이러한 함수들에서 errno의 행동을 잘 구현했다고 하더라도, errno가 에러를 잡아내는데 의존하기 보다는 함수 호출 전에 입력 값을 체크하기를 권장한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 0-3-2]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_18_04_01</rule>
		<ruleTitle><![CDATA[동적 힙 메모리 할당은 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 동적 메모리의 사용은 out-of-storage 런타임 실패를 가져온다. 대체된 버전이 아닌 built-in new, delete 연산자는 동적 힙 메모리를 사용한다. 함수 calloc, malloc, realloc, free 또한 동적 힙 메모리를 사용한다. 동적 메모리 할당과 관련된 unspecified, undefined, implementation-defined behavior의 범위가 있다. 동적 힙 메모리 할당은 메모리 누수, 데이터의 불일치, 메모리 고갈, 결정되지 않은 행동 등을 가져올 수 있다. 어떤 구현들에서는 다른 함수(예를 들면, cstring 라이브러리의 함수들)를 사용할 때 동적 힙 메모리 할당을 사용한다. 만약 이런 경우라면 이러한 함수들은 사용을 피해야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_08_02</rule>
		<ruleTitle><![CDATA[호출 가능한(viable) 함수 집합, 즉 최종 호출 함수를 선택하기 위한 집합에는 함수 템플릿 특수화가 포함되어 있지 않거나, 함수 템플릿 특수화로만 구성되어 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 오버로드 식별(overload resolution) 이후에 함수와 특수화된 함수가 같으면, 일반 함수가 선택된다. 이것은 개발자의 의도와는 다를 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
이 규칙은 복사 생성자 또는 복사 할당 연산자에는 적용하지 않는다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_08_01</rule>
		<ruleTitle><![CDATA[오버로드된 함수 템플릿의 명시적 특수화 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 명시적 특수화는 오버로드된 함수 식별(overload resolution) 이후에 고려되기 때문에 개발자의 의도와는 다른 결과를 초래한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_10_01</rule>
		<ruleTitle><![CDATA[서로 다른 식별자에 구별하기 어려운 문자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 문자를 출력하는 폰트에 따라 다른 문자라도 같은 형태로 보일 수 있다. 이런 경우에 개발자는 식별자를 다른 식별자와 혼동할 수 있다. <br/>
<br>검사 대상:<br/>
<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 대소문자만 다른 경우, 
<br>&nbsp;&nbsp;&nbsp;&nbsp;2. '_'문자의 유무,
<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 'O' 와 '0', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 'I' 와 '1', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 'I' 와 'l'(el),
<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 'l'(el) 과 '1', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;7. 'S' 와 '5', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;8. 'Z' 와 '2', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;9. 'n' 과 'h', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;10. 'B' 와 '8', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;11. 'rn' 과 'm' 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_10_02</rule>
		<ruleTitle><![CDATA[식별자는 외부 범위(scope)의 식별자(identifier)를 가리면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 내부에 선언한 식별자의 이름이 외부 scope의 식별자의 이름과 같으면 외부 식별자를 가려서 개발자에게 혼란을 줄 수 있다. <br/><br/>

내부, 외부 scope의 정의는 다음과 같다:<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;- file scope를 가진 식별자가 가장 외부의 scope 이다.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- block scpoe를 가진 식별자는 더 내부의 scope 이다.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 연속, 중첩된 block은 더 내부의 scope 이다.<br/><br/>
 ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_10_03</rule>
		<ruleTitle><![CDATA[typedef 이름에는 유일한 식별자를 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 class, union이나 enum의 이름을 다른 타입의 이름이나 목적으로 사용하면 개발자에게 혼란을 줄 수 있다. 
<br/><br/>같은 프로젝트 안의 class, union이나 enum 의 이름은 중복 사용해서는 안 된다. <br/><br/>정의가 헤더 파일에 존재하고 헤더 파일을 여러 소스 파일에서 가져다 사용하는 경우는 예외이다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_10_04</rule>
		<ruleTitle><![CDATA[class, union 이나 enum의 이름은 유일해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 class, union이나 enum의 이름을 다른 타입의 이름이나 목적으로 사용하면 개발자에게 혼란을 줄 수 있다. 
<br/><br/>같은 프로젝트 안의 class, union이나 enum 의 이름은 중복 사용해서는 안 된다. 
<br/><br/>정의가 헤더 파일에 존재하고 헤더 파일을 여러 소스 파일에서 가져다 사용하는 경우는 예외이다. 

<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_09_01</rule>
		<ruleTitle><![CDATA[객체나 함수의 선언과 정의에서 타입이 일치해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
선언된 객체나 함수의 타입이 원래의 것과 호환되더라도 토큰(token) 단위로 동일하지 않으면 개발자가 쉽게 혼동 할 수 있다. 따라서 이러한 요소는 최대한 배제해야 한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 3–2–1, Rule 3–9–2]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_10_05</rule>
		<ruleTitle><![CDATA[static 변수나 함수의 이름은 유일해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 scope에 관계 없이 static 식별자의 이름을 같은 프로젝트 안에서 사용하면 안 된다. 대상은 external linkage의 객체나 함수와 static 인 객체나 함수를 포함한다. 컴파일에는 문제가 없지만 개발자에게 혼란을 줄 수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 기본 숫자 타입인 char, int, short, long, float, double, long duble 대신 크기를 표현한 typedef를 사용해야 한다. 개발자는 typedef를 선언할 때, 타입들의 실제 구현을 알아야 한다. <br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
wchar_t 타입은 항상 wide character를 지원하는 타입에 맵핑되기 때문에 typedef가 필요하지 않다.<br/><br/>
char_t typedef 타입은 크기와 부호유무를 표시하지 않고 단순하게 char 객체가 기본 char 타입의 사용없이 선언되도록 허용한다.
그렇게 때문에 분석 도구에서 (plain)char를 검출하는 것을 허용한다.
<br/><br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_10_06</rule>
		<ruleTitle><![CDATA[변수나 함수에 타입과 같은 식별자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서는 C 호환성 때문에 같은 식별자를 타입과 변수, 혹은 타입과 함수에 사용 가능하다. 이는 개발자에게 혼란을 줄 수 있다. 

<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_09_03</rule>
		<ruleTitle><![CDATA[실수형을 underlying bit로 표현 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 실수형의 저장 형태는 컴파일러마다 다르므로 값을 직접 저장하는 방법으로 다루면 안 된다. in-built 연산자나 함수는 개발자에게 저장 형태를 숨겨야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_08_01</rule>
		<ruleTitle><![CDATA[shift 연산자의 오른쪽 피연산자가 적절한 값을 가지는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 shift 연산자의 오른쪽 피연산자는, 0과 왼쪽 피연산자의 underlying type의 bit 너비보다 1 작은 수 사이의 값을 가져야 한다.<br/><br/>
 그 값을 벗어나면 undefined behavior가 발생한다. 예를 들어, left-shift 또는 right-shift 연산자의 왼쪽 피연산자가 16-bit 정수형(integer)이라면, 0에서 15 사이의 값으로 shift 되는지 확인하는 것이 중요하다. 
<br/><br/>이 규칙을 따르는지 확인하는 다양한 방법이 있다. 가장 단순한 방법은 오른쪽 피연산자가 상수가 되는 경우이다. Unsigned integer 타입의 사용은 음수 값이 아니라는 것을 확인하고, 그러므로 최대 제한 값만을 확인하면 된다. 그렇지 않은 경우에는 양쪽 제한 값을 모두 확인해야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >See also</span></span> &nbsp; <br/><br/>
섹션 6.5.0의 underlying type 참고]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_18_02_01</rule>
		<ruleTitle><![CDATA[시스템 매크로 offsetof 는 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 피연산자의 타입이 호환 불가능하거나 비트필드가 사용되었을 때, 이 매크로를 사용하면 정의되지 않은 행동을 할 수 있다. (offsetof 함수: 자신의 부모 구조체의 시작 주소에서 멤버 주소까지의 거리(offset)을 반환하는 함수.) 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_11</rule>
		<ruleTitle><![CDATA[가상 함수가 아닌 함수에서 미사용 파라미터 선언 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
사용하지 않는 파라미터는 디자인 변경으로 인한 것이며, 이로 인해 실제 사용하는 함수 인자가 파라메터에 일치하지 않을 수 있다. 
<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
콜백 함수로 사용된 함수의 정의 내 이름없는 파라미터의 경우 이 규칙을 위반하지 않는다.</br></br>

<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 0–1–12]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_12</rule>
		<ruleTitle><![CDATA[가상 함수와 함수를 오버라이드 한 모든 함수의 미사용 파라미터 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
사용하지 않는 파라미터는 디자인 변경으로 인한 것이며, 이로 인해 실제 사용하는 함수 인자가 파라메터에 일치하지 않을 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 0–1–11]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_10</rule>
		<ruleTitle><![CDATA[함수를 정의하고 미사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
호출되지 않는 함수 또는 프로시져는 삭제되도 프로그램의 실행 의미에 전혀 영향을 주지 않는다. 하지만, 이런 함수나 프로시져는 유지보수를 필요하게 만들고 코드를 읽을 때 혼동을 야기시킨다. 따라서 프로그램에서 사용하지 않는 함수나 프로시져는 제거하는 것이 좋다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_08_05_02</rule>
		<ruleTitle><![CDATA[배열과 구조체의 non-zero 초기화에는 구조에 맞게 {}를 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 ISO/IEC 14882:2003[1]에서는 배열, 구조체, union 타입의 초기화 리스트에 {} 한 쌍을 사용하라고 기술되어 있다(그렇게 안 쓰는 경우엔 undefined behaviour 가 발생한다.). 이 규칙은 중첩된 구조인 경우 추가로 {} 를 더 쓰라고 한다. 이렇게 하면 개발자가 복잡한 데이터 타입에 대해 각 element가 어떤 순서로 초기화되는지 명확하게 알 수 있다.
<br/><br/> 배열이나 구조체의 zero 초기화는 top-level에만 적용한다(표준에서는 허용함). 배열이나 구조체의 non-zero 초기화는 각 element에 대한 명시적인 초기화가 되어야 한다. 배열이나 구조체의 모든 element가 첫 번째 element만 명시하면 나머지는 0 또는 NULL로 초기화 된다. 만일 이 방법을 선택하면, 첫 번째 element는 0 또는 NULL이어야 하고 중첩된 {}는 필요 없다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_08_05_03</rule>
		<ruleTitle><![CDATA[enumerator list 에서 초기화가 있다면, 첫 번째 멤버만 초기화 하거나 혹은 모든 멤버를 다 해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 enumerator list 가 명시적 멤버 초기화가 없으면 C++은 0부터 연속적인 정수 값을 할당한다. 첫 번째 멤버에 명시적 초기화를 하면 그 값부터 시작해서 할당하게 된다. 이렇게 하려면, 첫 번째 멤버의 초기화 값이 충분히 작아야 한다.
<br/><br/> 모든 멤버에 대한 명시적 초기화는 자동으로 부여되는 값과 개발자가 직접 부여한 값을 혼동하지 않도록 막아준다. 그러나 개발자가 모든 값이 적절한 범위 내에 있는지를 보장해야 하고 실수로 중복된 값을 부여해서는 안 된다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_06_01</rule>
		<ruleTitle><![CDATA[클래스 내에서 식별자 사용 형식 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 클래스 템플릿이 다른 클래스를 상속받는 경우, 상위 클래스에 있는 모든 식별자는 qualified-id 또는 this-> 를 이용해서 불러야 한다. Qualified-id나 this-> 를 이용하는 것이 개발자의 의도에 대한 일관성 있는 엔티티 참조를 보장한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_08_05_01</rule>
		<ruleTitle><![CDATA[모든 변수는 사용되기 전에 값이 할당되어 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙의 의도는 모든 변수가 읽히기 전에 쓰여야 한다는 것이다. 반드시 선언 시 초기화를 해야 하는 건 아니다.
<br/><br/> ISO/IEC 14882:2003[1]에 의하면, static storage duration을 갖는 변수들은 명시적 초기화가 없으면 자동으로 0으로 초기화된다고 한다. 그런데 현실적으로는 많은 임베디드 환경들이 이렇게 구현되어있지 않다. static storage duration은 static storage 클래스 명시자로 선언된 혹은 external linkage를 갖는 모든 변수들의 속성이다. automatic storage duration을 갖는 변수들은 보통 자동으로 초기화되지 않는다. <br/><br/>각 클래스 생성자는 모든 non-static 멤버를 초기화해야 한다. <br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_14_06_02</rule>
		<ruleTitle><![CDATA[Overload resolution이 식별하는 함수 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Argument-dependent lookup (ADL) 은 함수 호출을 처리할 때, 함수를 찾기 위한 찾기-범위(search-scope) 이외에도 associated 네임스페이스를 추가로 포함한다. 때문에 이 추가 네임스페이스가 overload resolution 결과에 영향을 줄 수 있다. 특히, 함수 템플릿인 경우 ADL 은 함수 템플릿의 instantiation 이 일어나는 시점에 작동하게 된다. 때문에, 템플릿 이후에 선언된 함수가 호출될 수 있다. 이것을 피하려면, 호출하려는 함수를 qualified name 으로 호출하거나 함수 이름을 괄호로 묶어서 호출해야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_00_03</rule>
		<ruleTitle><![CDATA[goto 나 switch 문장을 이용해 제어를 try 나 catch 내로 이동하면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 goto 나 switch 문장을 이용해 제어를 try 나 catch 로 이동하면 문법오류이다. 하지만, 모든 컴파일러가 이것을 에러로 처리하진 않는다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_00_01</rule>
		<ruleTitle><![CDATA[예외는 에러 핸들링을 위해서만 사용되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 (문서화) 예외는 에러핸들링으로만 사용해야 한다. 예외는 호출 트리 상의 제어를 이동시키므로 코드를 더욱 읽기 힘들게 만든다. 따라서, 예상치 못한 상황에서만 예외를 사용하고, 제대로 동작하는 프로그램에서는 나타나지 말아야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[기타]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_15_00_02</rule>
		<ruleTitle><![CDATA[예외 오브젝트는 포인터 타입이면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 동적으로 할당된 예외 오브젝트와 그것을 가리키는 포인터가 전달되는 경우, 그것을 처리하는 책임이 불확실해 진다. 값이나 레퍼런스인 경우에는 이러한 모호한 처리가 아예 존재하지 않으므로 훨씬 안전하다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_01_01</rule>
		<ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 만약 어떤 변수의 값이 수정될 필요가 없다면 const 키워드를 명시하여 수정되지 않도록 선언해야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §7.1.5.1]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_01_02</rule>
		<ruleTitle><![CDATA[포인터, 참조형 파라미터는 그 객체의 값이 변경되지 않는 경우 const 타입 객체를 가리켜야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 객체의 값이 수정될 필요가 없다면 const 타입의 객체를 가리키는 포인터, 참조형 파라미터를 사용해서 함수의 인터페이스를 명확히 해야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
파라미터 객체가 오버라이딩 된 함수에 의해 변경된 경우 적용하지 않는다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_08</rule>
		<ruleTitle><![CDATA[external side effect가 없는 void 타입 함수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
값을 반환하지 않고 external side effect가 없는 함수는 단지 시간을 낭비하고, 개발자가 기대하는 어떤 결과물 생성에도 관여하지 않을 것이다.<br />
<br />
 external side effect의 예: <br /><br />
 &nbsp;&nbsp;&nbsp;&nbsp; - 파일, 스트림 등의 읽기 또는 쓰기<br />
 &nbsp;&nbsp;&nbsp;&nbsp; - 지역 변수가 아닌 값의 변경<br />
 &nbsp;&nbsp;&nbsp;&nbsp; - 레퍼런스 타입 인자(argument) 값의 변경<br />
 &nbsp;&nbsp;&nbsp;&nbsp; - Volatile 객체의 사용<br />
 &nbsp;&nbsp;&nbsp;&nbsp; - 예외 발생</br></br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_09</rule>
		<ruleTitle><![CDATA[dead 코드 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 실행되는 코드를 제거해도 프로그램의 결과에 영향을 미치지 않을 때, 이러한 코드들이 dead 코드를 구성한다(redundant 코드로도 알려져 있다). 이는 reviewer가 보기에 의도한 것인지 실수인지 명확하지 않다. <br /><br />]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_06</rule>
		<ruleTitle><![CDATA[변수에 값을 할당한 후에 한 번도 사용하지 않는 프로세스 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 기술적으로 DU dataflow anomaly로 알려져 있다(이것은 어떤 변수에 값이 할당되고 사용하지 않는 process이다.). 이는 단지 비효율적인 측면뿐 아니라, 진짜 문제를 발생시킬 수 있다. 종종 이러한 구조는 loop 같은 statement 집합을 잘못 선택하기 때문에 일어난다.</br></br>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
Loop control variable ( Section 6.6.5 확인 )은 이 규칙에서 제외한다.</br></br>
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서 반환 값을 사용하지 않고 함수를 호출하는 것은 가능하지만, 이는 에러일 것이다. 함수의 반환 값은 항상 사용되어야 한다. Overloaded operators는 내장된 operator에서 같은 방식으로 행동하기 때문에 제외한다.</br></br>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
함수의 리턴값은 (void) 캐스팅의 사용으로 버려질 수 있다.</br></br>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 5–2–4]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_04</rule>
		<ruleTitle><![CDATA[한 번만 사용하는 volatile아닌 POD 변수 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 volatile아닌 POD(plain old data)변수를 선언하고 한 번만 사용하면 프로그램의 실행에 영향을 미치지 않는다. POD 변수는 숫자 타입, enum, 포인터, C 스타일의 구조체를 말한다. 사용이란 변수의 할당(명시적 초기화)이나 참조이다. 이러한 변수는 필요하지 않고 변수가 잘못 사용될 수 있다. Missing statement도 이러한 문제의 원인일 수 있다. </br></br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_05</rule>
		<ruleTitle><![CDATA[사용되지 않은 타입 선언 포함 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 타입이 선언되었지만 사용하지 않는다면, 리뷰어에게는 타입이 쓸모 없는 건지 실수로 쓰이지 않은 것인지 확실하지 않다. 따라서, 사용되지 않은 타입은 삭제하는 것이 좋다.</br></br>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_02</rule>
		<ruleTitle><![CDATA[실행 불가능한 경로 포함 금지]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
프로그림의 실행 경로에서 어떤 입력 데이터에 의해서도 실행할 수 없는 경로가 있을 수 있다. 실행 불가능한 경로는 다음에 의해서 발생된다.<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;- if, else문의 구조<br />
&nbsp;&nbsp;&nbsp;&nbsp;- 부적절하게 쓰여진 루프 구조<br /><br />
이러한 구조를 제거하기 위해 코드를 다시 작성할 수 있다. 하지만 이러한 과정은 다른 오류를 유발할 수 있다. <br />
방어적인(protective) 코딩 기술은 실행 불가능한 코드를 만들어낼 가능성이 있다. 이러한 코드는 유닛 테스팅 환경에서 실행 가능하다.<br /><br />
]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_03</rule>
		<ruleTitle><![CDATA[미사용 변수 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 프로젝트 내에서 선언하고 사용하지 않는 변수는 제거해도 프로그램 동작에 영향이 없으며, 이는 잘못된 변수 이름이 어딘가에서 사용되었다는 것을 가리킨다. 이러한 선언을 제거하는 것은, 정확한 변수 대신에 잘못된 변수가 이후에 사용될 가능성을 줄인다.</br></br>
 비트 필드 내에서 패딩(padding)을 사용했다면 padding 멤버는 사용되지 않을 것이고, 해당 규칙의 검출을 피하기 위하여 unnamed 이어야 한다</br></br> ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_01_01</rule>
		<ruleTitle><![CDATA[도달 불가능한 코드 포함 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 도달 불가능한 코드(unreachable code)는 코드에 도달할 수 있는 경로가 하나도 없는 코드이다. 이런 코드가 존재할 때, 이것이 의도적인 것인지, 적절한 경로가 우연히 빠진 것인지 확실하지 않다. <br/><br/>
컴파일러는 이러한 구조를 위한 코드를 생성하지 않으며, 의도하여 도달 불가능한 코드를 작성하였더라도 최종 실행 코드에는 반영되지 않는다. 편집 과정에서 빠진 문장(statements)이 보통 도달 불가능한 코드이다. <br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 함수(표준 라이브러리 부분이거나, third party library 또는 사용자에 의해 정의된 함수)가 에러를 발생시키는 것을 확인할 수 있다. 전역 오류 플래그, 파라미터 오류 플래그, 특별한 반환 값 등으로 확인 할 수 있다. 함수가 제공하는 어떤 메카니즘이던 프로그램은 함수가 반환된 후 가능한 한 빨리 에러가 있는지를 검사해야 한다. 그러나, 에러 예방을 위한 방법으로는 함수 입력 값을 검사하는 것이 함수 호출이 완료된 이후에 에러를 검사하려고 하는 것 보다 더욱 강력한 수단이다. 
<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 19–3–1]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_00_03_01</rule>
		<ruleTitle><![CDATA[런타임 오류 최소화 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp; Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 런타임 검사는 개발자들이 특별히 신경 써야 하는 부분이다. 특히, C+은 런타임 검사 지원이 취약하기 때문이다. C++ 구현은 안전한 소프트웨어를 위해 필요한 동적인 검사 진행이 요구되지 않는다. 그러므로 C++ 개발자는 런타임 에러가 발생할 수 있는 위치에 동적 검사 코드를 넣는 것을 고민하는 것이 필요하다. <br/><br/>

다음은 동적인 검사를 제공해야할 필요가 있는 영역에 대한 몇가지 지침을 제공한다.<br/><br/>

&nbsp;&nbsp;- 산술연산 에러<br/>
  이는 overflow, underflow, 0으로 나누기 또는 shifting을 통한 비트의 손실과 같은 수식의 평가를 포함한다.<br/><br/>
&nbsp;&nbsp;- 포인터 연산<br/>
 주소가 동적으로 계산될때, 계산된 주소가 올바른지 보장 해야 한다. 특히, 구조체나 배열 내부를 가리키는 포인터인 경우, 포인터가 증가, 감소 또는 변형될 때 포인터는 여전히 그 구조체나 배열을 가리켜야 한다.<br/><br/>
&nbsp;&nbsp;- 배열 경계 에러<br/>
배열의 인덱스 접근 시 그 범위 안에서 접근하는지 확인해야 한다.<br/><br/>
&nbsp;&nbsp;- 함수 인자<br/>
 함수인자는 검증되어야 한다.<br/><br/>
&nbsp;&nbsp;- 포인터 역참조<br/>
포인터를 반환하는 함수와 포인터가 역참조 되는 곳에서는 이 포인터가 NULL이 아닌지 확인해야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_13_05</rule>
		<ruleTitle><![CDATA[narrow string과 wide string literal을 연결해서 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 wide string과 narrow string literal 연결은 정의되지 않은 행위(undefined behaviour)를 유발한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_13_03</rule>
		<ruleTitle><![CDATA[unsigned 타입인 8진수나 16진수 literal에는 접미사를 'U'사용 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 정수 타입에 다음과 같은 요소에 의존한다:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 상수의 대소, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 상수 타입의 구현 크기(The implemented sizes of the integer types), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 접미사의 존재 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 값이 표현되는 숫자베이스( 10진수, 8준수, 16진수 등 )<br/><br/>
 예를들어, 0x8000은 16비트 환경에서는 unsigned이고, 32비트 환경에서는 signed int이다. unsigned int와 int를 overload했을 때 0x8000은 정수 크기의 구현에 의존한다. unsigned 값이면 'U' 접미사를 붙여야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_13_04</rule>
		<ruleTitle><![CDATA[literal의 접미사에 소문자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 literal의 접미사에 대문자를 사용하면'1' 과 'l'(el) 사이의 혼동을 없앨 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
ISO/IEC 14882:2003 [1] §2.13]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_13_01</rule>
		<ruleTitle><![CDATA[허용한 확장문자열만 사용 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 정의하지 않은 확장 문자열은 정의하지 않은 행위(undefined behaviour)를 유발한다. ISO/IED 14882:2003에서 정의한 확장문자열만 사용해야 한다.<br/> (\', \?, \\, \t, \v, \f, \a, \b, \n, \r, \0) 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 2-13-2
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_13_02</rule>
		<ruleTitle><![CDATA[8진수 확장 문자와 상수를 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
   0으로 시작하는 상수는 8진수로 취급한다. 따라서 개발자가 의도한 10진수와는 다른 값이 들어갈 수 있다. <br/><br/>8진수 확장 문자열의 마지막에 10진수가 들어가거나(8,9) 의도하지 않은 문자가 할당될 수 있다. <br/><br/>정수형 상수 0은 8진수 상수이지만 예외이다. '\0' 만이 유일하게 허락되는 8진수 확장 문자열이다. <br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_05_01</rule>
		<ruleTitle><![CDATA[for 루프의 loop-counter는 하나이고 실수형이 아니어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 for 루프의 loop-counter가 하나가 아니어야 하고, 둘 이상이 필요하다면 while 루프를 사용하는 편이 낫다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_05_06</rule>
		<ruleTitle><![CDATA[bool 타입이 아니고 loop-counter가 아닌 loop-control-variable은 for의 body에서 변경 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 loop-counter가 아닌 loop-control-variable은 loop-counter나 루프 종료를 위한 flag이다.  Boolean 값을 사용해야 코드를 이해하기 쉽다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_05_03</rule>
		<ruleTitle><![CDATA[loop-counter를 condition이나 statement에서 변경 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 for 루프의 expression이 아닌 곳에서 loop-counter가 변하면 좋은 형태가 아니다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_05_02</rule>
		<ruleTitle><![CDATA[loop-counter가 증감연산자로 값이 변하지 않을 때 조건식 안의 loop-counter는 ==, != 의 피연산자로 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 loop-counter는 증감 연산자로 값이 변하지 않을 때 조건식에서 ==, != 연산자를 사용하면 안 된다. 루프가 끝나지 않거나 개발자가 기대하지 않은 결과가 발생할 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_05_05</rule>
		<ruleTitle><![CDATA[loop-counter가 아닌 loop-control-variable은 condition이나 expression에서 변경 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 loop-control-variable은 loop-counter나 루프 종료를 위한 flag이다. 이 값이 condition이나 expression에서 변하지 않으면 코드를 이해하기 쉽다. volatile인 loop-control-variable은 statement 밖에서 값을 바뀔 수 있다. 이런 변화는 이 규칙을 위배하지 않는다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_05_04</rule>
		<ruleTitle><![CDATA[loop-counter의 값을 잘못된 형태로 증감 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 loop-counter의 값은 --, ++ 연산자를 사용하거나 -=n, +=n 형태로만 바꿔야 한다. n은 루프에서 상수이어야 한다. 이런 형태만이 유한한 루프를 보장한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_17_00_05</rule>
		<ruleTitle><![CDATA[setjmp 매크로와 longjmp 함수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 setjmp와 longjmp는 코드를 우회하기(bypass) 위한 함수 호출 메커니즘이다. 그러나 try-catch-finally 가 더욱 잘 정의된 메커니즘을 제공하기 때문에 setjmp와 longjmp는 사용하면 안 된다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_03_02</rule>
		<ruleTitle><![CDATA[main이란 이름을 갖는 함수는 오로지 전역에만 존재해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 main 함수는 프로그램의 시작 지점으로 사용되며 반드시 전역 namespace에 유일하게 존재해야 하는 함수이다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_03_01</rule>
		<ruleTitle><![CDATA[전역 namespace에는 main, namespace, extern C 선언만 있어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 namespace를 이용하여 함수, 변수 등을 관리하면 lookup하는 동안 검사해봐야 하는 엔티티의 수를 줄여 주고, 개발자가 기대한 이름을 찾는 것을 보장할 수 있도록 도와 준다. 따라서 main함수, namespace 선언들, extern C를 제외한 다른 선언은 전역에 존재하지 않아야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
규칙 3-9-2를 준수하는 정의된 타입은 전역 namespace에 존재할 수 있다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_03_06</rule>
		<ruleTitle><![CDATA[using-directive, using-declaration은 헤더 파일에서 사용하면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 using-directive, using-declaration을 헤더 파일에서 사용하면 헤더 파일의 include 순서에 따라 동작이 달라질 수 있다. 따라서 헤더 파일에서는 사용하면 안 된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §7.3.3, §7.3.4]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_03_05</rule>
		<ruleTitle><![CDATA[using-declaration 이후에 동일한 식별자에 대한 선언이 있으면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 using-declaration은 순서상 이후에 선언되는 동일한 식별자를 갖는 선언까지 introduce하지는 않는다. 이는 개발자의 의도와 다를 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §7.3.3]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_03_04</rule>
		<ruleTitle><![CDATA[using-directive를 사용하면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 using-directive를 사용하면 name lookup시 살펴봐야 할 scope이 많아지게 되고 이는 잦은 오류를 발생시킬 수 있다. using-declaration을 사용하거나 fully qualified name을 사용하는 것이 더 안전하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §7.3.4]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_07_03_03</rule>
		<ruleTitle><![CDATA[헤더 파일에는 unnamed namespace가 존재하면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 unnamed namespace는 각 translation unit(TU)마다 unique하다. 따라서 헤더 파일에 있는 unnamed namespace에 있는 선언들은 각 TU마다 다른 엔티티들을 가리키게 된다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_10_02_01</rule>
		<ruleTitle><![CDATA[다중 상속 계층 구조에서 접근 가능한 모든 엔티티의 이름은 유일해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 만약 이름이 모호하다면 컴파일러는 이 이름 충돌을 보고해야 하고 임의의, 그리고 예상치 못하게 resolve된 코드를 생성하지 않아야 한다. 그러나 이 모호성은 개발자에게 명확하지 않을 수 있다. 그러나 member function이 virtual이라면 base class를 명시적으로 참조함으로써 함수의 virtual 동작을 제거하여 모호성을 해결할 수 있다. 따라서 overload set을 구성하는 함수들은 검출하지 않는다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
이 규칙의 목적에 부합하기 위해, 오버로드 된 형태의 함수 식별자들은 같은 요소로 고려해야 한다.]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_04_05_01</rule>
		<ruleTitle><![CDATA[bool 타입 표현식을 특정 built-in 연산자의 피연산자로 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
논리 연산자(&&)와 비트 연산자(&)를 자주 혼동하는 경우가 있기 때문에, bool 타입의 피연산자를 대입 연산자, 논리 연산자, 관계 연산자, 참조 연산자나 조건 연산자가 아닌 연산자와 사용하는 것은 개발자의 실수일 수 있으므로 확인이 필요하다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_04_05_03</rule>
		<ruleTitle><![CDATA[char와 wchar_t 표현식을 특정 연산자의 피연산자로 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 = , ==, !=, &, +, -, <, <=, >, >= 외의 연산자를 char나 wcahr_t 에 사용하면 안 된다. character 데이터의 처리는 개발자가 예상하지 못한 결과를 발생시킬 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
예외적으로, 연관된 제약사항이 있다면, 다음의 연산자는 사용될 수 있다.<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 0-9 에서 '0'의 범위 내에서 정수값을 더하기 위해 + 연산자가 사용된 경우<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 문자 '0'에서 뺄셈을 위해 - 연산자가 사용된 경우<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 문자가 숫자를 나타내는지 확인하기 위해 관계 연산자 <,<=,>,>= 가 사용된 경우]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_04_05_02</rule>
		<ruleTitle><![CDATA[enum 타입 표현식을 특정 built-in 연산자의 피연산자로 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 enum 타입에는 [], =, ==, != , <, <=, >, >= 외의 연산자는 사용하면 안 된다. enum은 구현에 따라 정의(implementation-defined)되므로 산술 연산에 사용하면 안 된다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_02_05</rule>
		<ruleTitle><![CDATA[\ 문자는 헤더파일 이름에 포함 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 헤더 이름에 \ 문자가 < 와 > 사이에 들어가거나 " 사이에 들어간다면 정의되지 않은 동작을 할 수 있다. 어떤 환경에서는 \를 파일 이름 구분자로 사용하기 때문에 이 규칙은 심각도가 낮다. 이런 환경의 컴파일러는 종종 #include 지시자로 \의 사용을 지원한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_02_04</rule>
		<ruleTitle><![CDATA[', ", /*, // 문자는 헤더파일 이름에 포함 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 헤더 이름에 ', ", /* 또는 // 문자가 < 와 > 사이에 들어가거나, ', /* 또는 // 문자가 " 사이에 들어간다면 정의되지 않은 행동을 할 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_02_06</rule>
		<ruleTitle><![CDATA[#include 다음에는 <파일이름> 또는 "파일이름"이 따라와야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 표준 ISO/IEC 14882:2003 1 에 의해 허가된 #include 지시자로는 <파일이름> 또는 "파일이름"만이 허용된다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_02_01</rule>
		<ruleTitle><![CDATA[전처리자는 파일의 include와 include guard로만 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++은 인라인 함수나 상수 선언 등을 이용하면, 기존 C언어에서 전처리자를 이용하던 것보다 더욱 안전하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 16-2-2]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_02_03_01</rule>
		<ruleTitle><![CDATA[trigraph 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  Trigraph란 '??' 다음에 특정 문자열이 나오는 형태이다. 이 문자를 사용하면 '??' 를 사용하려고 했을 때와 혼동을 유발한다. <br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_02_03</rule>
		<ruleTitle><![CDATA[Include guard를 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 트랜스레이션 유닛이 중첩된 헤더 파일의 복잡한 구조를 가질 때, 특정 헤더 파일이 한 번 이상 include 될 수 있다. 이는 혼란을 가져올 수 있다. 만약 이러한 다수의 include가 충돌되는 정의를 가져온다면, 이것은 정의되지 않은 행동을 하거나 오류가 있을 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_02_02</rule>
		<ruleTitle><![CDATA[C++ 매크로는 include guard, type qualifier, storage class specifier로만 사용해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서 매크로는 include guard, type qualifier, storage class specifier로만 사용해야 한다. C++은 전처리자의 type-safe 대안으로 const 변수와 함수 템플릿을 제공한다. Type qualifier와 storage specifier로의 매크로 사용은 규칙 16-2-1을 위배함을 확인하라. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 16-2-1]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_08_03_01</rule>
		<ruleTitle><![CDATA[Overriding 함수가 Overridden 함수와 동일한 default argument를 사용하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Default argument는 객체의 정적 타입에 의해 결정된다. 만일 default argument 가 overriding 함수에서 다른 경우, base 객체로 호출할 때와 derived 객체로 호출할 때 결과가 달라진다. 이는 개발자의 생각과 다를 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §8.3.6(10)]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_00_02</rule>
		<ruleTitle><![CDATA[매크로는 전역 네임스페이스에 #define 되거나 #undef 되어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #define 또는 #undef 지시자가 소스파일 어디에 위치해도 에러가 발생하지는 않지만, 전역 네임스페이스가 아닌 곳에 위치하는 것은 보기와 달리 그들의 범위를 제한하지 않기 때문에 가독성을 해친다. 이는 개발자의 예상과 다를 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 16-0-3]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_00_03</rule>
		<ruleTitle><![CDATA[#undef는 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #undef는 일반적인 상황에서 필요하지 않다. #undef는 해당 매크로가 코드에서 사용되었을 때, 매크로가 존재하는지 또는 그 의미가 무엇인지 혼란을 가져올 수 있다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_00_04</rule>
		<ruleTitle><![CDATA[함수형 매크로 정의 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 매크로가 함수보다 빠르다는 이점이 있지만, 함수가 더욱 안전하고 튼튼한(robust) 메커니즘을 제공한다. 왜냐하면 함수는 파라미터의 타입을 검사하기 때문이다. 함수형 매크로의 문제는 파라미터를 잠재적으로 여러 번 evaluating 하는 것이다.  
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_00_05</rule>
		<ruleTitle><![CDATA[함수 매크로의 인자는 전처리 지시자처럼 보이는 토큰을 포함하면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 어떤 인자라도 전처리 지시자처럼 사용한다면, 매크로로 대체되었을 때의 동작은 예상할 수 없다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_00_01</rule>
		<ruleTitle><![CDATA[파일 내에서 #include 앞에는 다른 전처리 지시자 또는 주석만 허용 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 코드 가독성을 위해서 모든 #include 지시자는 파일의 첫 부분에 그룹화 되어야 한다. #include 앞에 위치할 수 있는 코드는 다른 전처리 지시자 또는 주석뿐이다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_03_01</rule>
		<ruleTitle><![CDATA[external linkage 변수나 함수는 헤더 파일에 선언해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 다른 translation unit에서 접근할 수 있도록 의도한 external linkage 변수나 함수 선언은 헤더파일에 있어야 한다. 
<br/><br/>만약 external linkage로 선언할 필요가 없으면 변수나 함수를 static으로 선언하거나 이름없는 namespace안에 선언해야 한다. 
<br/><br/>변수와 함수의 가시성(visibility)를 줄이는 좋은 행동이다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
main 이나 이름없는 namespace의 멤버는 예외이다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_03_03_02</rule>
		<ruleTitle><![CDATA[internal linkage인 함수는 static으로 재 선언해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 static 함수는 internal linkage다. 이런 함수의 재 선언은 static 예약어를 필요로 하지 않지만 여전히 internal linkage이다. 하지만 암시적이라 개발자에게 명확하지 않다. 그러므로 static을 명시적으로 표시하는 것이 좋다
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_18_00_05</rule>
		<ruleTitle><![CDATA[라이브러리 <cstring>의 unbounded 함수는 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 &lt;cstring&gt; 라이브러리의 strcpy, strcmp, strcat, strchr, strspn, strcspn, strpbrk, strrchr, strstr, strtok, strlen 함수들은 버퍼의 끝을 넘어서 읽거나 쓸 수 있기 때문에 정의되지 않은 행동을 할 수 있다. 안전한 string 핸들링 라이브러리를 사용해야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_18_00_04</rule>
		<ruleTitle><![CDATA[라이브러리 <ctime>의 시간 핸들링 함수는 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 시간의 포멧 같은 various aspects는 implementation-defined 또는 unspecified 이다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_06_03_01</rule>
		<ruleTitle><![CDATA[switch, while, do while 이나 for 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 switch, while, do while이나 for 문장의 body가 복합문(compound statement)이 아니면, 개발자가 한 문장인 body를 여러 문장인 body로 바꾸려 할 때 괄호를 사용하지 않아 오류가 발생할 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_18_00_01</rule>
		<ruleTitle><![CDATA[C 라이브러리 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 몇몇의 C++ 라이브러리(<cstdio> 등...)는 C버전<stdio.h> 에 해당한다. 이 규칙에서는 C++ 버전을 사용하라고 요구한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_18_00_03</rule>
		<ruleTitle><![CDATA[라이브러리 <cstdlib>의 함수 abort, exit, getenv, system은 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이러한 함수의 사용은 implementation-defined behaviour을 가져온다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_18_00_02</rule>
		<ruleTitle><![CDATA[라이브러리 <cstdlib>의 함수 atof, atoi 그리고 atol은 사용하면 안 된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 함수들은 string을 변환할 수 없을 때, 정의되지 않은 행동을 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 9899:1990 [16] §7.10.1]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_03_03</rule>
		<ruleTitle><![CDATA[unary & 연산자 오버로딩 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Complete 타입이 유저가 선언한 연산자 &를 포함할 때, incomplete 타입의 객체 주소를 가져오는 것은 undefined behaviour를 가져온다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.3.1(4)]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_00_06</rule>
		<ruleTitle><![CDATA[함수형 매크로의 정의에서, 인자의 각 인스턴스는 괄호로 둘러싸여야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 괄호가 사용되지 않으면, 프로세서가 매크로를 코드로 대체했을 때, 연산자 우선순위 때문에 개발자가 예상한대로 동작하지 않을 수 있다. 따라서 함수 매크로의 정의 내에서 인자는 괄호로 둘러싸여야 한다. (단, # 또는 ##의 피연산자는 예외) ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_03_04</rule>
		<ruleTitle><![CDATA[sizeof 연산의 피연산자는 side effect를 포함하지 않아야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/>
 C++에서 가능한 프로그래밍 에러는 sizeof 연산을 표현식에 적용하고 그 표현식이 실행되기를 기대하는 것이다. 그러나, sizeof는 표현식의 타입만을 대상으로 계산하기 때문에 그 표현식은 실행되지 않는다. 이러한 에러를 피하기 위해서, sizeof는 side effect를 포함하는 표현식을 사용하면 안 된다. <br/>
예를 들면, 40000은 32 비트 환경에서는 signed int 이지만 16 비트 환경에서는 signed long 이다. 0x8000은 16비트 환경에서는 unsigned int 이지만 32비트 환경에서는 signed int 이다.<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/>
sizeof ( i )에서 피연산자 i가 volatile 이면 허용된다.</br></br>

<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/>
ISO/IEC 14882:2003 [1] §3.2(2)]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_00_07</rule>
		<ruleTitle><![CDATA[정의되지 않은 매크로 식별자는 #if 또는 #elif 전처리 지시자 내에서 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 전처리 지시자 내에서 식별자를 사용하려고 했을 때, 그 식별자가 정의되지 않았다면 전처리자는 그 값을 0으로 가정한다. 단, #ifdef, #ifndef 그리고 #if defined는 매크로의 존재를 확인하기 위해 제공되므로 이러한 경우에 사용하는 것은 허용한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_03_01</rule>
		<ruleTitle><![CDATA[!, && 또는 || 연산자 각각의 피연산자는 bool 타입을 가져야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이러한 연산자들의 피연산자 타입이 bool이 아닌 경우, 그 의미가 의도와 다를 수 있다. &, |, ~ 연산자와 &&, ||, ! 연산자는 쉽게 혼동할 수 있기 때문에 이러한 규칙이 필요하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.14, §5.15]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_16_00_08</rule>
		<ruleTitle><![CDATA[# 토큰이 코드 라인의 첫 번째 토큰이라면, 곧 전처리 토큰이 따라와야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 소스코드의 어떤 부분이 전처리 지시자에 의해 제외된다면, 해당 문장들은 #else, #elif 또는 #endif를 만날 때까지 무시된다(문맥에 따라 다름). 만약 이렇게 제외된 지시자 중 하나가 잘못된 형식을 갖는다면, 컴파일러에 의한 warning도 없이 무시된다. 이 규칙이 요구하는 것은 비록 제외된 코드의 블록 내에 존재하더라도 모든 전처리지시자는 문법적으로 올바르게 사용되어야 한다는 것이다. 특히, #else 와 #endif 지시자의 뒤에 공백이 아닌 다른 문자가 붙은 것이 아닌지 주의해야 한다. 컴파일러가 항상 이를 체크하는 것은 아니다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_05_03_02</rule>
		<ruleTitle><![CDATA[unary minus 연산자는 표현식의 underlying type이 unsigned 일 때 사용하면 안 됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 unsigned int, unsigned long, unsigned long long 타입의 expression에 unary minus 연산자를 적용하는 것은 그 결과 타입도 같은 것으로 각각 생성하며, 의미있는 연산이 아니다. Unary minus를 충분히 작은 unsigned 정수 타입의 피연산자에 적용하는 것은 integral promotion에 의해 올바른 signed 결과를 가져오지만, 이것은 좋은 예가 아니다.  
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >See also</span></span> &nbsp; <br/><br/>
섹션 6.5.0의 underlying type 참고]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_17_00_03</rule>
		<ruleTitle><![CDATA[표준 라이브러리 함수와 같은 이름의 함수 재 선언 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 개발자가 표준 라이브러리 함수의 새로운 버전을 사용한다면(기능성 강화 또는 입력 값 검사를 위해), 수정된 함수는 새로운 이름을 가져야 한다. 그러나 기능이 기존 함수와 같다면, 새로운 파라미터를 추가해서 overload를 하는 것은 허용한다. 이는 함수의 이름과 기능이 일관되도록 한다. 예를 들어, sqrt 함수의 새로운 버전은 입력 값이 음수가 아님을 검사할 때, 이름을 sqrt라고 지으면 안 된다. 그러나 overload는 허용한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_17_00_04</rule>
		<ruleTitle><![CDATA[모든 라이브러리 코드는 MISRA C++을 따라야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 라이브러리의 품질은 나머지 프로젝트 코드들과 최소한 같은 표준을 따라야 한다. 라이브러리 코드는 소스코드 또는 객체코드로 존재할 수 있다. 각각의 라이브러리는 코드가 어떻게 MISRA C++를 준수하는지 증명하는 문서를 포함해야 한다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>매우낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_17_00_01</rule>
		<ruleTitle><![CDATA[표준 라이브러리에 예약된 식별자, 매크로, 함수는 define, redefine, 또는 undefine 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 표준 라이브러리에 정의된 매크로를 undef 하는 것은 일반적으로 나쁜 습관이다. 또한 C++에 예약된 식별자, C++ 키워드 또는 표준 라이브러리에 예약된 이름의 다른 매크로, 객체, 함수 이름으로 #define 하는 것도 마찬가지이다. 예를 들면 defined, __LINE__, __FILE__, __DATE__, __TIME__, __STDC__, errno 그리고 assert 처럼 재정의 또는 undefine 하면 정의되지 않은 행동을 하는 몇몇의 예약된 특정 단어와 함수 이름이 있다. 이 규칙은 헤더 파일이 실제로 include 되었는지 여부와는 상관 없다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 16-0-3]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_CPP_2008]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
		<rule>MISRA_CPP_17_00_02</rule>
		<ruleTitle><![CDATA[표준 라이브러리 매크로, 객체 이름의 재사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 개발자가 표준 라이브러리 매크로 또는 객체의 새 버전을 사용하면(기능성 강화 또는 입력 값 검사를 위해), 수정된 매크로 또는 객체는 새로운 이름을 가져야 한다. 왜냐하면 표준 매크로나 객체인지 아니면 수정된 버전인지 혼란을 피해야 하기 때문이다. 
<br/><br/>]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<bug>
		<violationHash>87797104018849838243643280867943822173</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>50</line>
		<rule>MISRA_CPP_06_06_05</rule>
		<ruleTitle><![CDATA[함수는 하나의 종료 지점만 함수의 끝에 있어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 miro_check 는 3 개의 exit point 를 가짐 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>36065401813485147612718193338877962550</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>22</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>48227394746406938312274829849841475650</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>87</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>67492324059452086151310957690403507771</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_CPP_05_14_01</rule>
		<ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1712760770641889423916400549890084196035</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_CPP_07_01_01</rule>
		<ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[변수 tail의 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>526273407116395757114600686023024498561</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>320062124246223348015314582429898738689</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>141461732453191641571637686022489969791</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>72</line>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[plain char 타입 check 가 문자 값의 사용 및 저장 외의 용도로 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>2475342263403159744719488342367974059</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_CPP_05_14_01</rule>
		<ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>90946989888708522384753766811914917810</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>105</line>
		<rule>MISRA_CPP_08_04_02</rule>
		<ruleTitle><![CDATA[함수 재 선언 시 이전 선언과 동일한 식별자를 갖는 파라미터를 써야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 재 선언 시 이전 선언과 동일한 식별자를 갖는 파라미터를 사용하지 않음(이전 선언(위치: "C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h"(57:1))의 식별자:move, 재 선언의 식별자:moving) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>100361504937245622774597307968633322193</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>48</line>
		<rule>MISRA_CPP_06_06_05</rule>
		<ruleTitle><![CDATA[함수는 하나의 종료 지점만 함수의 끝에 있어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 map_re_find 는 2 개의 exit point 를 가짐 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>48282881535346125311282151389814663584</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>8</line>
		<rule>MISRA_CPP_18_04_01</rule>
		<ruleTitle><![CDATA[동적 힙 메모리 할당은 사용하면 안 된다. ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[malloc(size_t)는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>7333721636934222314594180504859538397</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>35</line>
		<rule>MISRA_CPP_03_03_01</rule>
		<ruleTitle><![CDATA[external linkage 변수나 함수는 헤더 파일에 선언해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 miro_way_completionS의 정의 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>135723808798034468511663663339907396804</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>77</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>63647242909866971802757610907715630094</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>85</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>283669422314626194114349567308186617593</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<line>11</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>106620328253042989944698837240065656203</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>70</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1505368076058308249715990671052338715319</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>21</line>
		<rule>MISRA_CPP_07_01_01</rule>
		<ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[변수 tail의 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>30484617213291042708642790528702272811</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>123</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1257106875740142833512766719186185050518</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>138</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>168864360064463412067056578951767770674</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>134</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>879462121123984699814419848616283185840</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>213</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>211773155964199605511163071310047461437</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>9</line>
		<rule>MISRA_CPP_16_02_02</rule>
		<ruleTitle><![CDATA[C++ 매크로는 include guard, type qualifier, storage class specifier로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[허용되지 않는 형태의 매크로 wall가 정의됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>2342103245912096358211263623006662621</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>65</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>425879359125061449314447625114061273577</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>70</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>131270957866867449263385100237849222471</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>103</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>174138265749863900784095852650685969261</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>132</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>855372803420397865911906111766859230387</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>208</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>239879619258495516612982496915345619149</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>38</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>117350730506163237123713824011450231943</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>68</line>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[plain char 타입 check 가 문자 값의 사용 및 저장 외의 용도로 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>520647444598710594115103261202006839647</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>134</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>341389624633688478511102973519512661684</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>84</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1723142778410696395612320245768605218782</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>42</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>27749068098182683423578155609147800910</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>35</line>
		<rule>MISRA_CPP_07_01_01</rule>
		<ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[변수 tail의 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>15873679732694255564856496237660986472</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>132</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>167283346085751470193851053677046390031</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_CPP_05_14_01</rule>
		<ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>162539169788000570387318780254292579944</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>4</line>
		<rule>MISRA_CPP_07_01_01</rule>
		<ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[변수 map의 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1287369528837936338713306387782270805529</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>91</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>77632545793892467337176240590323238855</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>43</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14127821471603953302848248300633095062</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>218</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>21045948550596099364778743601880795492</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>73</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>13635169683781007959400835770612788182</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>28</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>12346632010853492555238323524765649910</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>88</line>
		<rule>MISRA_CPP_08_00_01</rule>
		<ruleTitle><![CDATA[하나의 declaration에 declarator 하나만 쓰는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>916752771950750484314140256995097093980</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>185</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1831959925704282362614993997583629459549</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>61</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>200528312987201295310349643971824639371</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>171</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1373922740896798142710885160491794133738</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>91</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1262670565575807891717162372786556055211</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>129</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1537781925396994821513587270912621161</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>37</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map2)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1206772114304541778212437177621576802099</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>148</line>
		<rule>MISRA_CPP_00_01_06</rule>
		<ruleTitle><![CDATA[변수에 값을 할당한 후에 한 번도 사용하지 않는 프로세스 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[기록만 하고 읽지 않는 변수(필드) num 가 존재함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>109243573776212469829736149870370779847</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>21</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>143459809449268472673342107506639729707</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>45</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>100822693644066968649667510781788582168</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>93</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>33265928175058260262015046313333647208</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>12</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1473433618205524383300968280636496272</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>62</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>176603612007483645196842312712750833069</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>99</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>73786505882333141506416491626721170852</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>7</line>
		<rule>MISRA_CPP_16_02_01</rule>
		<ruleTitle><![CDATA[전처리자는 파일의 include와 include guard로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[전처리자가 파일의 include 또는 include guard가 아닌 다른 용도로 사용됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>50293826629541514563859111206575135770</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>134</line>
		<rule>MISRA_CPP_18_04_01</rule>
		<ruleTitle><![CDATA[동적 힙 메모리 할당은 사용하면 안 된다. ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[free(void *)는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>266305317670014966915236127177464595853</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>99</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>541119950994721056510771294638086158478</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>73</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 getchar의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1576137088749427590511336591485647451308</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>15</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>487767546687936842812394300173459546960</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>140</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>43176888586170235281665174378414674464</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>140</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>119089904008436999411689241833692488775</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>79</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>793090913264325945414034900710408549773</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>111</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>12953243640090237699911224704224605459</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>141</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>15798004900317295946523020115448642226</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>128</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>45398344968920062056017053661157148477</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1442347733333678710213493673311046402863</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>38</line>
		<rule>MISRA_CPP_08_05_01</rule>
		<ruleTitle><![CDATA[모든 변수는 사용되기 전에 값이 할당되어 있어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[변수 node는 값이 할당되지 않았을 가능성이 있음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>69752185350351517426308410177833306119</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>83</line>
		<rule>MISRA_CPP_03_03_01</rule>
		<ruleTitle><![CDATA[external linkage 변수나 함수는 헤더 파일에 선언해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 miro_return의 정의 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>609931972546222151017935237120141316812</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>157</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>174688496769981773716241512141098209991</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>7</line>
		<rule>MISRA_CPP_18_00_03</rule>
		<ruleTitle><![CDATA[라이브러리 <cstdlib>의 함수 abort, exit, getenv, system은 사용하면 안 된다. ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[system(const char *)는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1395355905309343392518268651697022467782</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>14</line>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[plain char 타입 check 가 문자 값의 사용 및 저장 외의 용도로 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1109928280259324239313623671122031151719</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>99</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>706363532805741160411685457443353226887</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>97</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>663200158787212177211563752742158608529</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>140</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>550178875181486894115654921537356975716</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>81</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>146474354292971336632166342155493043010</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>1</line>
		<rule>MISRA_CPP_16_02_03</rule>
		<ruleTitle><![CDATA[Include guard를 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[헤더 파일의 중복 금지를 위한 처리(#ifndef, #define, #endif)가 이루어지지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>711777211214611256910442654954847864091</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>15</line>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[plain char 타입 check 가 문자 값의 사용 및 저장 외의 용도로 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>284025932218293331410963154916668878168</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>59</line>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[plain char 타입 check 가 문자 값의 사용 및 저장 외의 용도로 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1714923422833886866016576130749119014267</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>138</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1557046975859443268111949398152125323963</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>113</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>141068001300056347935825987145880269715</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>57</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>8149871446851634235078681919261286824</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>4</line>
		<rule>MISRA_CPP_07_01_02</rule>
		<ruleTitle><![CDATA[포인터, 참조형 파라미터는 그 객체의 값이 변경되지 않는 경우 const 타입 객체를 가리켜야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[참조형 변수 map의 *map 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>32502267270358513273353529522967088728</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>35</line>
		<rule>MISRA_CPP_00_01_06</rule>
		<ruleTitle><![CDATA[변수에 값을 할당한 후에 한 번도 사용하지 않는 프로세스 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[기록만 하고 읽지 않는 변수(필드) tail 가 존재함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>69367341136544264388493927726054650646</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_CPP_07_01_02</rule>
		<ruleTitle><![CDATA[포인터, 참조형 파라미터는 그 객체의 값이 변경되지 않는 경우 const 타입 객체를 가리켜야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[참조형 변수 tail의 *tail 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>22277031651640385841928638731418088197</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>43</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1216527480437444830013464093909196052213</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>19</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[char basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>134057236187108499638032326897243751372</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>130</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>170116133938411175914923178165678785101</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>74</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>30053256309164929638096403495466553537</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<line>3</line>
		<rule>MISRA_CPP_07_01_01</rule>
		<ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[변수 a의 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>94973809360453142972840811183082915565</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>53</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1371258771040593718813928242646093501771</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>33</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>177194728016939292712895729732276737333</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>6</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>142266457047225379834196376001970304091</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>9466729030620944298862635002428445707</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>10</line>
		<rule>MISRA_CPP_16_02_01</rule>
		<ruleTitle><![CDATA[전처리자는 파일의 include와 include guard로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[전처리자가 파일의 include 또는 include guard가 아닌 다른 용도로 사용됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>30961634202508868225370740687646931541</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>52</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>142985068553138875837124936733526163645</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>24</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>134378783024607764937564461512435924232</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>15</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1425248998727500622810655345404529926815</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>136</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>118185162044896375053866240239965330896</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>178</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>170748689355773058937964179214245366959</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>81</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>65133404703940881734924215543871570567</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>27649177791941250662752106215511413600</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>52</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1292155000142780922714387029806960570259</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>4</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>18956067945751400101337371378795282939</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>74</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>407595330667298268613461409568126798284</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>63</line>
		<rule>MISRA_CPP_18_00_03</rule>
		<ruleTitle><![CDATA[라이브러리 <cstdlib>의 함수 abort, exit, getenv, system은 사용하면 안 된다. ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[system(const char *)는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>38269772062432142186899605314947222503</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>9</line>
		<rule>MISRA_CPP_16_02_01</rule>
		<ruleTitle><![CDATA[전처리자는 파일의 include와 include guard로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[전처리자가 파일의 include 또는 include guard가 아닌 다른 용도로 사용됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>393081280305063814014621679152454687161</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>63</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1778977899631694040513406238159115521905</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>12</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 fputs의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>41074238356700701697430998997716587191</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>8</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 fputs의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>105390212478179008661489998308119341680</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>200</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>186163647375544795015298501136850117429</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>17</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 fputs의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>68919363701726986035883618085248133871</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>77</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map2)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>136762375649329389767683815669047947497</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>110</line>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[plain char 타입 check 가 문자 값의 사용 및 저장 외의 용도로 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>855003922124625087314737121999981349640</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>234</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 getchar의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>723603541922608896810313892158373416921</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>81</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 getchar의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>965163615836113721410201011462539128180</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>35</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>754252618701180767916761716123950286504</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>12</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>903273080533434152510050053478863347611</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>80</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>982014337513501139711470299215819484758</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>128</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1356006537590681917913166391753858615005</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>63</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 system 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>119933310109714988309473570454524662334</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>61</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 getchar의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>239001120365855580512077716798625735557</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>30</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>157692914980208907546721454131860027484</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>90</line>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[plain char 타입 check 가 문자 값의 사용 및 저장 외의 용도로 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>26252894553589875982672113293953014797</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>17</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>150891897648544316226238337215520125689</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>133</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>121666108717648287943324230906629084925</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>135</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1815858897863855458811440356489691525129</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>185</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>360708432719736950513865550387320476867</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>59</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>86791975214788843135369225597432238040</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>37</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>171465242079383434439011243121883761451</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>101</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 getchar의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>77638605370856398294525225807623054997</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>114</line>
		<rule>MISRA_CPP_18_04_01</rule>
		<ruleTitle><![CDATA[동적 힙 메모리 할당은 사용하면 안 된다. ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[free(void *)는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>88289498502751969228915440127117365754</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>24</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>176556252336194454275740363595284483693</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>78</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>69629131087082661772876785151019998464</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>15</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>98664841836737419632868251096522965754</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_CPP_05_14_01</rule>
		<ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>50192583894782843246283413391504994849</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>88</line>
		<rule>MISRA_CPP_17_00_02</rule>
		<ruleTitle><![CDATA[표준 라이브러리 매크로, 객체 이름의 재사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[remove는 선언 및 정의가 금지된 변수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>712762796042497918515504616301905819294</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>193</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1388077690329403027313704348758740620350</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>45</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>110708865362401533332651085291698953710</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>49</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 getchar의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>801144621878378308417522404840891826068</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>47</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>195002968276255245415988416705560925408</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>213</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>91066759269340846858442558383329240340</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>123</line>
		<rule>MISRA_CPP_06_06_04</rule>
		<ruleTitle><![CDATA[반복문은 하나의 break나 goto로만 종료해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반복문에 jump 문이 최대 하나만 사용되어야 하는데 9 번 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>28946811865391647351700841430687772762</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>74</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 fputs의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>2813253446018648269649392889235810490</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>44</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>40318614727124162237668374991855759415</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>34</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>166384283851111001544425176154231401091</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>200</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1521987531559018352310417598815672532905</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>105</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(re_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>37748346569830764788007338821254316363</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>11</line>
		<rule>MISRA_CPP_16_02_02</rule>
		<ruleTitle><![CDATA[C++ 매크로는 include guard, type qualifier, storage class specifier로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[허용되지 않는 형태의 매크로 find가 정의됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1050746180683624525611446356024976615786</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>99</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 getchar의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>23956642217386919836121787841457919968</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>49</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1273045246487200158815121937897206364443</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>74</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1577699011265956089810353653583084427961</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>121</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>917146302903133643818081125529987268872</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>10</line>
		<rule>MISRA_CPP_16_02_02</rule>
		<ruleTitle><![CDATA[C++ 매크로는 include guard, type qualifier, storage class specifier로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[허용되지 않는 형태의 매크로 way가 정의됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1092166381381165500154029104232593513</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<line>3</line>
		<rule>MISRA_CPP_07_01_02</rule>
		<ruleTitle><![CDATA[포인터, 참조형 파라미터는 그 객체의 값이 변경되지 않는 경우 const 타입 객체를 가리켜야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[참조형 변수 a의 *a 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1005332350674220279710815777970992754310</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>178</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>102719571551482675265394021892911599948</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>130</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>24019590307300143810035535700164517348</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>65</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>321695423981483565416859960281474362836</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>7</line>
		<rule>MISRA_CPP_08_05_02</rule>
		<ruleTitle><![CDATA[배열과 구조체의 non-zero 초기화에는 구조에 맞게 {}를 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열과 구조체 초기화 시 brace를 통해 구조가 매치되지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>733895352026013231312884451413874469965</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>157</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>215698569638279762813468084262381699303</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>101</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>175655942336900197634448771500008636599</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>142</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1626090366750190797215610239027402025116</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>83</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14180007177621016825794476632645768144</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>164</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>60109837317787073637977560406429656601</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>174423561563020517817765509260534137596</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>5</line>
		<rule>MISRA_CPP_08_00_01</rule>
		<ruleTitle><![CDATA[하나의 declaration에 declarator 하나만 쓰는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>82434099214042976731090117685955515924</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>14</line>
		<rule>MISRA_CPP_02_10_06</rule>
		<ruleTitle><![CDATA[변수나 함수에 타입과 같은 식별자 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[identifier 'link'은 타입과 이름이 같음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>555981645305856449313196644308944529761</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>11</line>
		<rule>MISRA_CPP_16_02_01</rule>
		<ruleTitle><![CDATA[전처리자는 파일의 include와 include guard로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[전처리자가 파일의 include 또는 include guard가 아닌 다른 용도로 사용됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>102388594897686521227403590127188538647</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>65</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map2)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>115942990757679422796127217001037862715</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>25</line>
		<rule>MISRA_CPP_07_01_01</rule>
		<ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[변수 map의 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>116875125597368465074703924716716661930</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>50</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>167561777444235015848820948580617769222</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>89</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>99625236345550919112029147298646128451</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>91</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1488555799527879044815751893823565148782</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>27</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>25256857864446364061915700028945947392</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>54</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>576908793960683308317307318653509318075</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>53</line>
		<rule>MISRA_CPP_08_00_01</rule>
		<ruleTitle><![CDATA[하나의 declaration에 declarator 하나만 쓰는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>153834586437061081625674018436347198439</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>95</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(re_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>154945654697072797016382182812248112114</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>139</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>4524237450729795697432997088550978643</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_CPP_05_14_01</rule>
		<ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>68565189530888167075988363428825073301</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>97</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1510037595816727781917680378647977605676</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>115565854982076767695562463788904597127</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>93</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1604413223769103293314198512003472328422</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>8</line>
		<rule>MISRA_CPP_16_02_02</rule>
		<ruleTitle><![CDATA[C++ 매크로는 include guard, type qualifier, storage class specifier로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[허용되지 않는 형태의 매크로 my가 정의됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>46992550330825772251157651981049665315</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>10</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>135992495590914188264191831476129822608</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>52</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 fputs의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>16003253444865533053129477960175362274</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>52</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>79194505572693970576234186535960062030</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>737462675278333914414639017447748695971</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>94</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1813879831942036272015834693041656212877</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>19</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1587286034525335290612596813521776616879</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>25</line>
		<rule>MISRA_CPP_07_01_02</rule>
		<ruleTitle><![CDATA[포인터, 참조형 파라미터는 그 객체의 값이 변경되지 않는 경우 const 타입 객체를 가리켜야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[참조형 변수 map의 *map 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>330570608708118720113302234664929947231</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>30</line>
		<rule>MISRA_CPP_18_04_01</rule>
		<ruleTitle><![CDATA[동적 힙 메모리 할당은 사용하면 안 된다. ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[malloc(size_t)는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>89086735278742233774317851489922747913</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<line>5</line>
		<rule>MISRA_CPP_08_00_01</rule>
		<ruleTitle><![CDATA[하나의 declaration에 declarator 하나만 쓰는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>556232300433453369212331032746254891688</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>125</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>11191132647110971448788263365362872425</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>131</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>877410777850214319914657926974613269954</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>124731271272217940536303222243010589204</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_CPP_05_14_01</rule>
		<ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1732422450981593296516225736745652796171</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>65</line>
		<rule>MISRA_CPP_07_01_01</rule>
		<ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[변수 head의 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>71000104958392879364257153408639200570</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>137</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>169939909892477525614848524060653365803</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>208</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>168886487175573441717170409976444030765</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>171</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>113024618468158569284105893290948781280</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>234</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 getchar 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1550885248077721651713520823310785604232</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>8</line>
		<rule>MISRA_CPP_16_02_01</rule>
		<ruleTitle><![CDATA[전처리자는 파일의 include와 include guard로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[전처리자가 파일의 include 또는 include guard가 아닌 다른 용도로 사용됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>267104190444352974613762851773678623290</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>106</line>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[plain char 타입 check 가 문자 값의 사용 및 저장 외의 용도로 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>742635651780390980517385432159506518751</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>41</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>176066091256658309027775584761779891996</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>86</line>
		<rule>MISRA_CPP_07_01_01</rule>
		<ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[변수 head의 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>21852880250140873536759056767036373237</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>87</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 getchar의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>72771700646918196693073378282569608411</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>136</line>
		<rule>MISRA_CPP_18_04_01</rule>
		<ruleTitle><![CDATA[동적 힙 메모리 할당은 사용하면 안 된다. ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[free(void *)는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>157455356940932110574969691929801119726</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>47</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1513941301759485211011373442711961509546</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<line>5</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>582307509927519348616492151820806511638</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>126</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1204696850810710657317033313321465027691</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>86</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(re_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>108438642030155418924063489259039494458</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>40</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>22389635401475278342223781408435391473</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>193</line>
		<rule>MISRA_CPP_00_03_02</rule>
		<ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>152988831684272124882607282916423779053</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>43</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1108834709938442999415920448156943669618</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>20</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1580205213234974219014278766946061262159</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>91</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>126270806862785753242852556707531254336</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>91</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map2)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>134308574160228850163138861885003479630</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>50</line>
		<rule>MISRA_CPP_05_00_11</rule>
		<ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[plain char 타입 check 가 문자 값의 사용 및 저장 외의 용도로 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>30346717131647705828902397475113858799</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>6</line>
		<rule>MISRA_CPP_08_00_01</rule>
		<ruleTitle><![CDATA[하나의 declaration에 declarator 하나만 쓰는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>553039003067566359017267649686463257363</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>28</line>
		<rule>MISRA_CPP_08_00_01</rule>
		<ruleTitle><![CDATA[하나의 declaration에 declarator 하나만 쓰는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1262639379459882685416730522838391609296</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>33</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>158150728640203920931569537373859599925</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>126</line>
		<rule>MISRA_CPP_05_02_01</rule>
		<ruleTitle><![CDATA[AND 또는 OR의 각 피연산자는 후위 표현식(postfix-expression)이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[&& 혹은 || 의 피연산자가 postfix-expression이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>114574890649788657115459208318758525058</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>7</line>
		<rule>MISRA_CPP_18_04_01</rule>
		<ruleTitle><![CDATA[동적 힙 메모리 할당은 사용하면 안 된다. ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[malloc(size_t)는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>30862955623749604815261563380244562673</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>7</line>
		<rule>MISRA_CPP_16_02_02</rule>
		<ruleTitle><![CDATA[C++ 매크로는 include guard, type qualifier, storage class specifier로만 사용해야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[허용되지 않는 형태의 매크로 mx가 정의됨. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>795481960425254539218133068543903406622</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_CPP_05_14_01</rule>
		<ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>80414458802704558391313440364256217494</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>97</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>921052748015840566613249857537925380004</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>65</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>144060009426001982516324665791165251449</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>164</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1101730616459138751112122766831037652742</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>67</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1521328304859476441818123393386941878415</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_CPP_05_14_01</rule>
		<ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[논리연산자 && 혹은 ||의 오른쪽 피연산자가 side effect를 가지면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>8826208989394171366479336556369822234</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>127</line>
		<rule>MISRA_CPP_06_04_01</rule>
		<ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>65112649393420352619952615422650307251</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>8</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 fputs 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>25300901679957006909088313937554145169</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>57</line>
		<rule>MISRA_CPP_03_09_02</rule>
		<ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[int basic type 이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1620180985053787188317373637260399062972</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>71</line>
		<rule>MISRA_CPP_05_02_12</rule>
		<ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[함수 인자로 들어온 배열 타입의 식별자(miro_map)가 망가져서(decay) 배열의 크기 값을 가지고 있지 않음. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>333085880452990203913884949824667831442</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>99</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>88643306680111813214002019308824048612</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>7</line>
		<rule>MISRA_CPP_00_01_07</rule>
		<ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 system 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>519146445821097928112508343974427420151</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>60</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17085901570628836006247698753574030064</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>50</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>22453240736517738926464385092571300612</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>136</line>
		<rule>MISRA_CPP_05_00_15</rule>
		<ruleTitle><![CDATA[배열 인덱싱은 포인터 연산의 유일한 형태이어야 함]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[포인터 연산이 배열의 인덱싱 형태로 쓰이지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>6306048113758006648580898076358510444</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>56</line>
		<rule>MISRA_CPP_02_07_03</rule>
		<ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[CPP 스타일 주석을 중첩하여 사용하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>137498197734337359402795146056364421637</violationHash>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>103</line>
		<rule>MISRA_CPP_18_04_01</rule>
		<ruleTitle><![CDATA[동적 힙 메모리 할당은 사용하면 안 된다. ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[free(void *)는 사용이 금지된 함수임 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>NaN</ncf>
		<ndf>2.0</ndf>
		<necl>7.0</necl>
		<modifiedCyclomaticComplexity>3.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>3.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>8.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>8.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>2.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<cc>8.0</cc>
		<ncl>4.0</ncl>
		<nfp>1.0</nfp>
		<ncf>2.0</ncf>
		<ndf>3.0</ndf>
		<necl>22.0</necl>
		<modifiedCyclomaticComplexity>8.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>11.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>29.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>29.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>2.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>1.0</nfp>
		<ncf>4.0</ncf>
		<ndf>8.0</ndf>
		<necl>9.0</necl>
		<modifiedCyclomaticComplexity>3.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>3.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>8.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>8.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>4.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>2.0</ndf>
		<necl>5.0</necl>
		<modifiedCyclomaticComplexity>2.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>2.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>4.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>4.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<cc>4.0</cc>
		<ncl>3.0</ncl>
		<nfp>4.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>14.0</necl>
		<modifiedCyclomaticComplexity>4.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>4.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>3.0</returnPointsCnt>
		<MCDCCaseCnt>16.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>16.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>0.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>NaN</ncf>
		<ndf>0.0</ndf>
		<necl>3.0</necl>
		<modifiedCyclomaticComplexity>2.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>2.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>4.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>4.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>0.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>0.0</nfp>
		<ncf>NaN</ncf>
		<ndf>27.0</ndf>
		<necl>28.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>12.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<cc>5.0</cc>
		<ncl>3.0</ncl>
		<nfp>2.0</nfp>
		<ncf>2.0</ncf>
		<ndf>1.0</ndf>
		<necl>12.0</necl>
		<modifiedCyclomaticComplexity>5.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>7.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>16.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>16.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<cc>5.0</cc>
		<ncl>2.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>12.0</ndf>
		<necl>29.0</necl>
		<modifiedCyclomaticComplexity>5.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>7.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>2.0</returnPointsCnt>
		<MCDCCaseCnt>16.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>16.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>9.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>0.0</nfp>
		<ncf>3.0</ncf>
		<ndf>2.0</ndf>
		<necl>9.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<cc>29.0</cc>
		<ncl>11.0</ncl>
		<nfp>4.0</nfp>
		<ncf>2.0</ncf>
		<ndf>22.0</ndf>
		<necl>91.0</necl>
		<modifiedCyclomaticComplexity>29.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>9729.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>168.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>168.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>7.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>5.0</necl>
		<modifiedCyclomaticComplexity>3.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>3.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>8.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>8.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>0.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>3.0</ncf>
		<ndf>1.0</ndf>
		<necl>10.0</necl>
		<modifiedCyclomaticComplexity>2.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>2.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>4.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>4.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>3.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>10.0</necl>
		<modifiedCyclomaticComplexity>3.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>3.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>9.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>9.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>0.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>4.0</necl>
		<modifiedCyclomaticComplexity>2.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>2.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>4.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>4.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>2.0</ndf>
		<necl>7.0</necl>
		<modifiedCyclomaticComplexity>3.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>3.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>8.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>8.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>2.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<fileMetric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun.c</fileName>
		<functionCnt>5</functionCnt>
		<physicalLineCnt>269.0</physicalLineCnt>
		<lineOfCodeCnt>182.0</lineOfCodeCnt>
		<lineOfCommentCnt>20</lineOfCommentCnt>
	</fileMetric>
	<fileMetric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.h</fileName>
		<functionCnt>0</functionCnt>
		<physicalLineCnt>66.0</physicalLineCnt>
		<lineOfCodeCnt>29.0</lineOfCodeCnt>
		<lineOfCommentCnt>20</lineOfCommentCnt>
	</fileMetric>
	<fileMetric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\miro_fun2.c</fileName>
		<functionCnt>4</functionCnt>
		<physicalLineCnt>112.0</physicalLineCnt>
		<lineOfCodeCnt>71.0</lineOfCodeCnt>
		<lineOfCommentCnt>10</lineOfCommentCnt>
	</fileMetric>
	<fileMetric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\Q_S.c</fileName>
		<functionCnt>1</functionCnt>
		<physicalLineCnt>203.0</physicalLineCnt>
		<lineOfCodeCnt>53.0</lineOfCodeCnt>
		<lineOfCommentCnt>94</lineOfCommentCnt>
	</fileMetric>
	<fileMetric>
		<fileName>C:\Users\hjo\Desktop\STAT_Directory\miro\QS_fun.c</fileName>
		<functionCnt>6</functionCnt>
		<physicalLineCnt>140.0</physicalLineCnt>
		<lineOfCodeCnt>103.0</lineOfCodeCnt>
		<lineOfCommentCnt>12</lineOfCommentCnt>
	</fileMetric>
</ci.CodeInspectorResult>
